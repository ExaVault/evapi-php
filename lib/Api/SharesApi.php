<?php
/**
 * SharesApi
 * PHP version 5
 *
 * @category Class
 * @package  ExaVault
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * ExaVault API
 *
 * See our API reference documentation at https://www.exavault.com/developer/api-docs/
 *
 * OpenAPI spec version: 2.0
 * Contact: support@exavault.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.22
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace ExaVault\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use ExaVault\ApiException;
use ExaVault\Configuration;
use ExaVault\HeaderSelector;
use ExaVault\ObjectSerializer;

/**
 * SharesApi Class Doc Comment
 *
 * @category Class
 * @package  ExaVault
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class SharesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addShare
     *
     * Creates a share
     *
     * @param  string $ev_api_key API Key required to make the API call. (required)
     * @param  string $ev_access_token Access token required to make the API call. (required)
     * @param  \ExaVault\Model\Body16 $body body (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ExaVault\Model\ShareResponse
     */
    public function addShare($ev_api_key, $ev_access_token, $body = null)
    {
        list($response) = $this->addShareWithHttpInfo($ev_api_key, $ev_access_token, $body);
        return $response;
    }

    /**
     * Operation addShareWithHttpInfo
     *
     * Creates a share
     *
     * @param  string $ev_api_key API Key required to make the API call. (required)
     * @param  string $ev_access_token Access token required to make the API call. (required)
     * @param  \ExaVault\Model\Body16 $body (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ExaVault\Model\ShareResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function addShareWithHttpInfo($ev_api_key, $ev_access_token, $body = null)
    {
        $returnType = '\ExaVault\Model\ShareResponse';
        $request = $this->addShareRequest($ev_api_key, $ev_access_token, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ExaVault\Model\ShareResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addShareAsync
     *
     * Creates a share
     *
     * @param  string $ev_api_key API Key required to make the API call. (required)
     * @param  string $ev_access_token Access token required to make the API call. (required)
     * @param  \ExaVault\Model\Body16 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addShareAsync($ev_api_key, $ev_access_token, $body = null)
    {
        return $this->addShareAsyncWithHttpInfo($ev_api_key, $ev_access_token, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addShareAsyncWithHttpInfo
     *
     * Creates a share
     *
     * @param  string $ev_api_key API Key required to make the API call. (required)
     * @param  string $ev_access_token Access token required to make the API call. (required)
     * @param  \ExaVault\Model\Body16 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addShareAsyncWithHttpInfo($ev_api_key, $ev_access_token, $body = null)
    {
        $returnType = '\ExaVault\Model\ShareResponse';
        $request = $this->addShareRequest($ev_api_key, $ev_access_token, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addShare'
     *
     * @param  string $ev_api_key API Key required to make the API call. (required)
     * @param  string $ev_access_token Access token required to make the API call. (required)
     * @param  \ExaVault\Model\Body16 $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addShareRequest($ev_api_key, $ev_access_token, $body = null)
    {
        // verify the required parameter 'ev_api_key' is set
        if ($ev_api_key === null || (is_array($ev_api_key) && count($ev_api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ev_api_key when calling addShare'
            );
        }
        // verify the required parameter 'ev_access_token' is set
        if ($ev_access_token === null || (is_array($ev_access_token) && count($ev_access_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ev_access_token when calling addShare'
            );
        }

        $resourcePath = '/shares';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ev_api_key !== null) {
            $headerParams['ev-api-key'] = ObjectSerializer::toHeaderValue($ev_api_key);
        }
        // header params
        if ($ev_access_token !== null) {
            $headerParams['ev-access-token'] = ObjectSerializer::toHeaderValue($ev_access_token);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation completeDirectSend
     *
     * Complete send files
     *
     * @param  string $ev_api_key API Key (required)
     * @param  string $ev_access_token Access Token (required)
     * @param  int $id ID of the share to trigger invitations for. (required)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ExaVault\Model\ShareResponse
     */
    public function completeDirectSend($ev_api_key, $ev_access_token, $id)
    {
        list($response) = $this->completeDirectSendWithHttpInfo($ev_api_key, $ev_access_token, $id);
        return $response;
    }

    /**
     * Operation completeDirectSendWithHttpInfo
     *
     * Complete send files
     *
     * @param  string $ev_api_key API Key (required)
     * @param  string $ev_access_token Access Token (required)
     * @param  int $id ID of the share to trigger invitations for. (required)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ExaVault\Model\ShareResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function completeDirectSendWithHttpInfo($ev_api_key, $ev_access_token, $id)
    {
        $returnType = '\ExaVault\Model\ShareResponse';
        $request = $this->completeDirectSendRequest($ev_api_key, $ev_access_token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ExaVault\Model\ShareResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation completeDirectSendAsync
     *
     * Complete send files
     *
     * @param  string $ev_api_key API Key (required)
     * @param  string $ev_access_token Access Token (required)
     * @param  int $id ID of the share to trigger invitations for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function completeDirectSendAsync($ev_api_key, $ev_access_token, $id)
    {
        return $this->completeDirectSendAsyncWithHttpInfo($ev_api_key, $ev_access_token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation completeDirectSendAsyncWithHttpInfo
     *
     * Complete send files
     *
     * @param  string $ev_api_key API Key (required)
     * @param  string $ev_access_token Access Token (required)
     * @param  int $id ID of the share to trigger invitations for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function completeDirectSendAsyncWithHttpInfo($ev_api_key, $ev_access_token, $id)
    {
        $returnType = '\ExaVault\Model\ShareResponse';
        $request = $this->completeDirectSendRequest($ev_api_key, $ev_access_token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'completeDirectSend'
     *
     * @param  string $ev_api_key API Key (required)
     * @param  string $ev_access_token Access Token (required)
     * @param  int $id ID of the share to trigger invitations for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function completeDirectSendRequest($ev_api_key, $ev_access_token, $id)
    {
        // verify the required parameter 'ev_api_key' is set
        if ($ev_api_key === null || (is_array($ev_api_key) && count($ev_api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ev_api_key when calling completeDirectSend'
            );
        }
        // verify the required parameter 'ev_access_token' is set
        if ($ev_access_token === null || (is_array($ev_access_token) && count($ev_access_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ev_access_token when calling completeDirectSend'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling completeDirectSend'
            );
        }

        $resourcePath = '/shares/complete-send/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ev_api_key !== null) {
            $headerParams['ev-api-key'] = ObjectSerializer::toHeaderValue($ev_api_key);
        }
        // header params
        if ($ev_access_token !== null) {
            $headerParams['ev-access-token'] = ObjectSerializer::toHeaderValue($ev_access_token);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteShareById
     *
     * Deactivate a share
     *
     * @param  int $id ID of the share entry (required)
     * @param  string $ev_api_key API Key required to make the API call. (required)
     * @param  string $ev_access_token Access token required to make the API call. (required)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ExaVault\Model\EmptyResponse
     */
    public function deleteShareById($id, $ev_api_key, $ev_access_token)
    {
        list($response) = $this->deleteShareByIdWithHttpInfo($id, $ev_api_key, $ev_access_token);
        return $response;
    }

    /**
     * Operation deleteShareByIdWithHttpInfo
     *
     * Deactivate a share
     *
     * @param  int $id ID of the share entry (required)
     * @param  string $ev_api_key API Key required to make the API call. (required)
     * @param  string $ev_access_token Access token required to make the API call. (required)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ExaVault\Model\EmptyResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteShareByIdWithHttpInfo($id, $ev_api_key, $ev_access_token)
    {
        $returnType = '\ExaVault\Model\EmptyResponse';
        $request = $this->deleteShareByIdRequest($id, $ev_api_key, $ev_access_token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ExaVault\Model\EmptyResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteShareByIdAsync
     *
     * Deactivate a share
     *
     * @param  int $id ID of the share entry (required)
     * @param  string $ev_api_key API Key required to make the API call. (required)
     * @param  string $ev_access_token Access token required to make the API call. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteShareByIdAsync($id, $ev_api_key, $ev_access_token)
    {
        return $this->deleteShareByIdAsyncWithHttpInfo($id, $ev_api_key, $ev_access_token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteShareByIdAsyncWithHttpInfo
     *
     * Deactivate a share
     *
     * @param  int $id ID of the share entry (required)
     * @param  string $ev_api_key API Key required to make the API call. (required)
     * @param  string $ev_access_token Access token required to make the API call. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteShareByIdAsyncWithHttpInfo($id, $ev_api_key, $ev_access_token)
    {
        $returnType = '\ExaVault\Model\EmptyResponse';
        $request = $this->deleteShareByIdRequest($id, $ev_api_key, $ev_access_token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteShareById'
     *
     * @param  int $id ID of the share entry (required)
     * @param  string $ev_api_key API Key required to make the API call. (required)
     * @param  string $ev_access_token Access token required to make the API call. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteShareByIdRequest($id, $ev_api_key, $ev_access_token)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteShareById'
            );
        }
        // verify the required parameter 'ev_api_key' is set
        if ($ev_api_key === null || (is_array($ev_api_key) && count($ev_api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ev_api_key when calling deleteShareById'
            );
        }
        // verify the required parameter 'ev_access_token' is set
        if ($ev_access_token === null || (is_array($ev_access_token) && count($ev_access_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ev_access_token when calling deleteShareById'
            );
        }

        $resourcePath = '/shares/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ev_api_key !== null) {
            $headerParams['ev-api-key'] = ObjectSerializer::toHeaderValue($ev_api_key);
        }
        // header params
        if ($ev_access_token !== null) {
            $headerParams['ev-access-token'] = ObjectSerializer::toHeaderValue($ev_access_token);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getShareById
     *
     * Get a share
     *
     * @param  int $id ID of the share entry (required)
     * @param  string $ev_api_key API Key (required)
     * @param  string $ev_access_token Access Token (required)
     * @param  string $include Comma separated list of relationships to include in response. Possible values are **owner**, **resources**, **notifications**, **activity**. (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ExaVault\Model\ShareResponse
     */
    public function getShareById($id, $ev_api_key, $ev_access_token, $include = null)
    {
        list($response) = $this->getShareByIdWithHttpInfo($id, $ev_api_key, $ev_access_token, $include);
        return $response;
    }

    /**
     * Operation getShareByIdWithHttpInfo
     *
     * Get a share
     *
     * @param  int $id ID of the share entry (required)
     * @param  string $ev_api_key API Key (required)
     * @param  string $ev_access_token Access Token (required)
     * @param  string $include Comma separated list of relationships to include in response. Possible values are **owner**, **resources**, **notifications**, **activity**. (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ExaVault\Model\ShareResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getShareByIdWithHttpInfo($id, $ev_api_key, $ev_access_token, $include = null)
    {
        $returnType = '\ExaVault\Model\ShareResponse';
        $request = $this->getShareByIdRequest($id, $ev_api_key, $ev_access_token, $include);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ExaVault\Model\ShareResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getShareByIdAsync
     *
     * Get a share
     *
     * @param  int $id ID of the share entry (required)
     * @param  string $ev_api_key API Key (required)
     * @param  string $ev_access_token Access Token (required)
     * @param  string $include Comma separated list of relationships to include in response. Possible values are **owner**, **resources**, **notifications**, **activity**. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getShareByIdAsync($id, $ev_api_key, $ev_access_token, $include = null)
    {
        return $this->getShareByIdAsyncWithHttpInfo($id, $ev_api_key, $ev_access_token, $include)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getShareByIdAsyncWithHttpInfo
     *
     * Get a share
     *
     * @param  int $id ID of the share entry (required)
     * @param  string $ev_api_key API Key (required)
     * @param  string $ev_access_token Access Token (required)
     * @param  string $include Comma separated list of relationships to include in response. Possible values are **owner**, **resources**, **notifications**, **activity**. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getShareByIdAsyncWithHttpInfo($id, $ev_api_key, $ev_access_token, $include = null)
    {
        $returnType = '\ExaVault\Model\ShareResponse';
        $request = $this->getShareByIdRequest($id, $ev_api_key, $ev_access_token, $include);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getShareById'
     *
     * @param  int $id ID of the share entry (required)
     * @param  string $ev_api_key API Key (required)
     * @param  string $ev_access_token Access Token (required)
     * @param  string $include Comma separated list of relationships to include in response. Possible values are **owner**, **resources**, **notifications**, **activity**. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getShareByIdRequest($id, $ev_api_key, $ev_access_token, $include = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getShareById'
            );
        }
        // verify the required parameter 'ev_api_key' is set
        if ($ev_api_key === null || (is_array($ev_api_key) && count($ev_api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ev_api_key when calling getShareById'
            );
        }
        // verify the required parameter 'ev_access_token' is set
        if ($ev_access_token === null || (is_array($ev_access_token) && count($ev_access_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ev_access_token when calling getShareById'
            );
        }

        $resourcePath = '/shares/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include !== null) {
            $queryParams['include'] = ObjectSerializer::toQueryValue($include, null);
        }
        // header params
        if ($ev_api_key !== null) {
            $headerParams['ev-api-key'] = ObjectSerializer::toHeaderValue($ev_api_key);
        }
        // header params
        if ($ev_access_token !== null) {
            $headerParams['ev-access-token'] = ObjectSerializer::toHeaderValue($ev_access_token);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listShares
     *
     * Get a list of shares
     *
     * @param  string $ev_api_key API Key required to make the API call. (required)
     * @param  string $ev_access_token Access token required to make the API call. (required)
     * @param  int $offset Current offset of records (for pagination) (optional)
     * @param  int $limit Limit of records to be returned (for pagination) (optional, default to 100)
     * @param  string $scope Set of shares to return. (**all**&#x3D;all of them, **active**&#x3D;shares that are currently active, **curentUser**&#x3D;shares created by you) (optional)
     * @param  string $sort What order the list of matches should be in. (optional)
     * @param  string $type Limit the list of matches to only certain types of shares. (optional)
     * @param  string $include Comma separated list of relationships to include in response. Possible values are **owner**, **resources**, **notifications**, **activity**. (optional)
     * @param  string $name When provided, only shares whose names include this value will be in the list. Supports wildcards, such as **send\\*** to return everything starting with \&quot;send\&quot;.  Use this parameter if you are searching for shares or receives for a specific folder name. For example **_/Clients/ACME/To Be Processed**. (optional)
     * @param  string $recipient Filter the results to include only shares that invited a certain email address. Supports wildcard matching so that **\\*@example.com** will give back entries shared with addresses ending in \&quot;@example.com\&quot;. (optional)
     * @param  string $message When provided, only shares with a message that contains the text will be included in the list of matches. Both the subject and the body of all messages will be checked for matches. This will allways be a wildcard match, so that searching for **taxes** will return any shares with a message that contains the word \&quot;taxes\&quot;. (optional)
     * @param  string $username When provided, only shares created by the user with that &#x60;username&#x60; will be included in the list. Does not support wildcard searching. (optional)
     * @param  string $search Searches the share name, username, recipients, share messages fields for the provided value. Supports wildcard searches. (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ExaVault\Model\ShareCollectionResponse
     */
    public function listShares($ev_api_key, $ev_access_token, $offset = null, $limit = '100', $scope = null, $sort = null, $type = null, $include = null, $name = null, $recipient = null, $message = null, $username = null, $search = null)
    {
        list($response) = $this->listSharesWithHttpInfo($ev_api_key, $ev_access_token, $offset, $limit, $scope, $sort, $type, $include, $name, $recipient, $message, $username, $search);
        return $response;
    }

    /**
     * Operation listSharesWithHttpInfo
     *
     * Get a list of shares
     *
     * @param  string $ev_api_key API Key required to make the API call. (required)
     * @param  string $ev_access_token Access token required to make the API call. (required)
     * @param  int $offset Current offset of records (for pagination) (optional)
     * @param  int $limit Limit of records to be returned (for pagination) (optional, default to 100)
     * @param  string $scope Set of shares to return. (**all**&#x3D;all of them, **active**&#x3D;shares that are currently active, **curentUser**&#x3D;shares created by you) (optional)
     * @param  string $sort What order the list of matches should be in. (optional)
     * @param  string $type Limit the list of matches to only certain types of shares. (optional)
     * @param  string $include Comma separated list of relationships to include in response. Possible values are **owner**, **resources**, **notifications**, **activity**. (optional)
     * @param  string $name When provided, only shares whose names include this value will be in the list. Supports wildcards, such as **send\\*** to return everything starting with \&quot;send\&quot;.  Use this parameter if you are searching for shares or receives for a specific folder name. For example **_/Clients/ACME/To Be Processed**. (optional)
     * @param  string $recipient Filter the results to include only shares that invited a certain email address. Supports wildcard matching so that **\\*@example.com** will give back entries shared with addresses ending in \&quot;@example.com\&quot;. (optional)
     * @param  string $message When provided, only shares with a message that contains the text will be included in the list of matches. Both the subject and the body of all messages will be checked for matches. This will allways be a wildcard match, so that searching for **taxes** will return any shares with a message that contains the word \&quot;taxes\&quot;. (optional)
     * @param  string $username When provided, only shares created by the user with that &#x60;username&#x60; will be included in the list. Does not support wildcard searching. (optional)
     * @param  string $search Searches the share name, username, recipients, share messages fields for the provided value. Supports wildcard searches. (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ExaVault\Model\ShareCollectionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listSharesWithHttpInfo($ev_api_key, $ev_access_token, $offset = null, $limit = '100', $scope = null, $sort = null, $type = null, $include = null, $name = null, $recipient = null, $message = null, $username = null, $search = null)
    {
        $returnType = '\ExaVault\Model\ShareCollectionResponse';
        $request = $this->listSharesRequest($ev_api_key, $ev_access_token, $offset, $limit, $scope, $sort, $type, $include, $name, $recipient, $message, $username, $search);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ExaVault\Model\ShareCollectionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listSharesAsync
     *
     * Get a list of shares
     *
     * @param  string $ev_api_key API Key required to make the API call. (required)
     * @param  string $ev_access_token Access token required to make the API call. (required)
     * @param  int $offset Current offset of records (for pagination) (optional)
     * @param  int $limit Limit of records to be returned (for pagination) (optional, default to 100)
     * @param  string $scope Set of shares to return. (**all**&#x3D;all of them, **active**&#x3D;shares that are currently active, **curentUser**&#x3D;shares created by you) (optional)
     * @param  string $sort What order the list of matches should be in. (optional)
     * @param  string $type Limit the list of matches to only certain types of shares. (optional)
     * @param  string $include Comma separated list of relationships to include in response. Possible values are **owner**, **resources**, **notifications**, **activity**. (optional)
     * @param  string $name When provided, only shares whose names include this value will be in the list. Supports wildcards, such as **send\\*** to return everything starting with \&quot;send\&quot;.  Use this parameter if you are searching for shares or receives for a specific folder name. For example **_/Clients/ACME/To Be Processed**. (optional)
     * @param  string $recipient Filter the results to include only shares that invited a certain email address. Supports wildcard matching so that **\\*@example.com** will give back entries shared with addresses ending in \&quot;@example.com\&quot;. (optional)
     * @param  string $message When provided, only shares with a message that contains the text will be included in the list of matches. Both the subject and the body of all messages will be checked for matches. This will allways be a wildcard match, so that searching for **taxes** will return any shares with a message that contains the word \&quot;taxes\&quot;. (optional)
     * @param  string $username When provided, only shares created by the user with that &#x60;username&#x60; will be included in the list. Does not support wildcard searching. (optional)
     * @param  string $search Searches the share name, username, recipients, share messages fields for the provided value. Supports wildcard searches. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listSharesAsync($ev_api_key, $ev_access_token, $offset = null, $limit = '100', $scope = null, $sort = null, $type = null, $include = null, $name = null, $recipient = null, $message = null, $username = null, $search = null)
    {
        return $this->listSharesAsyncWithHttpInfo($ev_api_key, $ev_access_token, $offset, $limit, $scope, $sort, $type, $include, $name, $recipient, $message, $username, $search)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listSharesAsyncWithHttpInfo
     *
     * Get a list of shares
     *
     * @param  string $ev_api_key API Key required to make the API call. (required)
     * @param  string $ev_access_token Access token required to make the API call. (required)
     * @param  int $offset Current offset of records (for pagination) (optional)
     * @param  int $limit Limit of records to be returned (for pagination) (optional, default to 100)
     * @param  string $scope Set of shares to return. (**all**&#x3D;all of them, **active**&#x3D;shares that are currently active, **curentUser**&#x3D;shares created by you) (optional)
     * @param  string $sort What order the list of matches should be in. (optional)
     * @param  string $type Limit the list of matches to only certain types of shares. (optional)
     * @param  string $include Comma separated list of relationships to include in response. Possible values are **owner**, **resources**, **notifications**, **activity**. (optional)
     * @param  string $name When provided, only shares whose names include this value will be in the list. Supports wildcards, such as **send\\*** to return everything starting with \&quot;send\&quot;.  Use this parameter if you are searching for shares or receives for a specific folder name. For example **_/Clients/ACME/To Be Processed**. (optional)
     * @param  string $recipient Filter the results to include only shares that invited a certain email address. Supports wildcard matching so that **\\*@example.com** will give back entries shared with addresses ending in \&quot;@example.com\&quot;. (optional)
     * @param  string $message When provided, only shares with a message that contains the text will be included in the list of matches. Both the subject and the body of all messages will be checked for matches. This will allways be a wildcard match, so that searching for **taxes** will return any shares with a message that contains the word \&quot;taxes\&quot;. (optional)
     * @param  string $username When provided, only shares created by the user with that &#x60;username&#x60; will be included in the list. Does not support wildcard searching. (optional)
     * @param  string $search Searches the share name, username, recipients, share messages fields for the provided value. Supports wildcard searches. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listSharesAsyncWithHttpInfo($ev_api_key, $ev_access_token, $offset = null, $limit = '100', $scope = null, $sort = null, $type = null, $include = null, $name = null, $recipient = null, $message = null, $username = null, $search = null)
    {
        $returnType = '\ExaVault\Model\ShareCollectionResponse';
        $request = $this->listSharesRequest($ev_api_key, $ev_access_token, $offset, $limit, $scope, $sort, $type, $include, $name, $recipient, $message, $username, $search);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listShares'
     *
     * @param  string $ev_api_key API Key required to make the API call. (required)
     * @param  string $ev_access_token Access token required to make the API call. (required)
     * @param  int $offset Current offset of records (for pagination) (optional)
     * @param  int $limit Limit of records to be returned (for pagination) (optional, default to 100)
     * @param  string $scope Set of shares to return. (**all**&#x3D;all of them, **active**&#x3D;shares that are currently active, **curentUser**&#x3D;shares created by you) (optional)
     * @param  string $sort What order the list of matches should be in. (optional)
     * @param  string $type Limit the list of matches to only certain types of shares. (optional)
     * @param  string $include Comma separated list of relationships to include in response. Possible values are **owner**, **resources**, **notifications**, **activity**. (optional)
     * @param  string $name When provided, only shares whose names include this value will be in the list. Supports wildcards, such as **send\\*** to return everything starting with \&quot;send\&quot;.  Use this parameter if you are searching for shares or receives for a specific folder name. For example **_/Clients/ACME/To Be Processed**. (optional)
     * @param  string $recipient Filter the results to include only shares that invited a certain email address. Supports wildcard matching so that **\\*@example.com** will give back entries shared with addresses ending in \&quot;@example.com\&quot;. (optional)
     * @param  string $message When provided, only shares with a message that contains the text will be included in the list of matches. Both the subject and the body of all messages will be checked for matches. This will allways be a wildcard match, so that searching for **taxes** will return any shares with a message that contains the word \&quot;taxes\&quot;. (optional)
     * @param  string $username When provided, only shares created by the user with that &#x60;username&#x60; will be included in the list. Does not support wildcard searching. (optional)
     * @param  string $search Searches the share name, username, recipients, share messages fields for the provided value. Supports wildcard searches. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listSharesRequest($ev_api_key, $ev_access_token, $offset = null, $limit = '100', $scope = null, $sort = null, $type = null, $include = null, $name = null, $recipient = null, $message = null, $username = null, $search = null)
    {
        // verify the required parameter 'ev_api_key' is set
        if ($ev_api_key === null || (is_array($ev_api_key) && count($ev_api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ev_api_key when calling listShares'
            );
        }
        // verify the required parameter 'ev_access_token' is set
        if ($ev_access_token === null || (is_array($ev_access_token) && count($ev_access_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ev_access_token when calling listShares'
            );
        }

        $resourcePath = '/shares';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, null);
        }
        // query params
        if ($scope !== null) {
            $queryParams['scope'] = ObjectSerializer::toQueryValue($scope, null);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort, null);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type, null);
        }
        // query params
        if ($include !== null) {
            $queryParams['include'] = ObjectSerializer::toQueryValue($include, null);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name, null);
        }
        // query params
        if ($recipient !== null) {
            $queryParams['recipient'] = ObjectSerializer::toQueryValue($recipient, null);
        }
        // query params
        if ($message !== null) {
            $queryParams['message'] = ObjectSerializer::toQueryValue($message, null);
        }
        // query params
        if ($username !== null) {
            $queryParams['username'] = ObjectSerializer::toQueryValue($username, null);
        }
        // query params
        if ($search !== null) {
            $queryParams['search'] = ObjectSerializer::toQueryValue($search, null);
        }
        // header params
        if ($ev_api_key !== null) {
            $headerParams['ev-api-key'] = ObjectSerializer::toHeaderValue($ev_api_key);
        }
        // header params
        if ($ev_access_token !== null) {
            $headerParams['ev-access-token'] = ObjectSerializer::toHeaderValue($ev_access_token);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateShareById
     *
     * Update a share
     *
     * @param  \ExaVault\Model\Body17 $body body (required)
     * @param  string $ev_api_key API Key (required)
     * @param  string $ev_access_token Access Token (required)
     * @param  int $id ID of the share entry (required)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ExaVault\Model\ShareResponse
     */
    public function updateShareById($body, $ev_api_key, $ev_access_token, $id)
    {
        list($response) = $this->updateShareByIdWithHttpInfo($body, $ev_api_key, $ev_access_token, $id);
        return $response;
    }

    /**
     * Operation updateShareByIdWithHttpInfo
     *
     * Update a share
     *
     * @param  \ExaVault\Model\Body17 $body (required)
     * @param  string $ev_api_key API Key (required)
     * @param  string $ev_access_token Access Token (required)
     * @param  int $id ID of the share entry (required)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ExaVault\Model\ShareResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateShareByIdWithHttpInfo($body, $ev_api_key, $ev_access_token, $id)
    {
        $returnType = '\ExaVault\Model\ShareResponse';
        $request = $this->updateShareByIdRequest($body, $ev_api_key, $ev_access_token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ExaVault\Model\ShareResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateShareByIdAsync
     *
     * Update a share
     *
     * @param  \ExaVault\Model\Body17 $body (required)
     * @param  string $ev_api_key API Key (required)
     * @param  string $ev_access_token Access Token (required)
     * @param  int $id ID of the share entry (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateShareByIdAsync($body, $ev_api_key, $ev_access_token, $id)
    {
        return $this->updateShareByIdAsyncWithHttpInfo($body, $ev_api_key, $ev_access_token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateShareByIdAsyncWithHttpInfo
     *
     * Update a share
     *
     * @param  \ExaVault\Model\Body17 $body (required)
     * @param  string $ev_api_key API Key (required)
     * @param  string $ev_access_token Access Token (required)
     * @param  int $id ID of the share entry (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateShareByIdAsyncWithHttpInfo($body, $ev_api_key, $ev_access_token, $id)
    {
        $returnType = '\ExaVault\Model\ShareResponse';
        $request = $this->updateShareByIdRequest($body, $ev_api_key, $ev_access_token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateShareById'
     *
     * @param  \ExaVault\Model\Body17 $body (required)
     * @param  string $ev_api_key API Key (required)
     * @param  string $ev_access_token Access Token (required)
     * @param  int $id ID of the share entry (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateShareByIdRequest($body, $ev_api_key, $ev_access_token, $id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateShareById'
            );
        }
        // verify the required parameter 'ev_api_key' is set
        if ($ev_api_key === null || (is_array($ev_api_key) && count($ev_api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ev_api_key when calling updateShareById'
            );
        }
        // verify the required parameter 'ev_access_token' is set
        if ($ev_access_token === null || (is_array($ev_access_token) && count($ev_access_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ev_access_token when calling updateShareById'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateShareById'
            );
        }

        $resourcePath = '/shares/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ev_api_key !== null) {
            $headerParams['ev-api-key'] = ObjectSerializer::toHeaderValue($ev_api_key);
        }
        // header params
        if ($ev_access_token !== null) {
            $headerParams['ev-access-token'] = ObjectSerializer::toHeaderValue($ev_access_token);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
