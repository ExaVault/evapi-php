<?php
/**
 * ResourcesApi
 * PHP version 5
 *
 * @category Class
 * @package  ExaVault
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * ExaVault API
 *
 * See our API reference documentation at https://www.exavault.com/developer/api-docs/
 *
 * OpenAPI spec version: 2.0
 * Contact: support@exavault.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.22
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace ExaVault\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use ExaVault\ApiException;
use ExaVault\Configuration;
use ExaVault\HeaderSelector;
use ExaVault\ObjectSerializer;

/**
 * ResourcesApi Class Doc Comment
 *
 * @category Class
 * @package  ExaVault
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ResourcesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addFolder
     *
     * Create a folder
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  \ExaVault\Model\AddFolderRequestBody $body body (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ExaVault\Model\ResourceResponse
     */
    public function addFolder($evApiKey, $evAccessToken, $body = null)
    {
        list($response) = $this->addFolderWithHttpInfo($evApiKey, $evAccessToken, $body);
        return $response;
    }

    /**
     * Operation addFolderWithHttpInfo
     *
     * Create a folder
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  \ExaVault\Model\AddFolderRequestBody $body (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ExaVault\Model\ResourceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function addFolderWithHttpInfo($evApiKey, $evAccessToken, $body = null)
    {
        $returnType = '\ExaVault\Model\ResourceResponse';
        $request = $this->addFolderRequest($evApiKey, $evAccessToken, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ExaVault\Model\ResourceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addFolderAsync
     *
     * Create a folder
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  \ExaVault\Model\AddFolderRequestBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addFolderAsync($evApiKey, $evAccessToken, $body = null)
    {
        return $this->addFolderAsyncWithHttpInfo($evApiKey, $evAccessToken, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addFolderAsyncWithHttpInfo
     *
     * Create a folder
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  \ExaVault\Model\AddFolderRequestBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addFolderAsyncWithHttpInfo($evApiKey, $evAccessToken, $body = null)
    {
        $returnType = '\ExaVault\Model\ResourceResponse';
        $request = $this->addFolderRequest($evApiKey, $evAccessToken, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addFolder'
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  \ExaVault\Model\AddFolderRequestBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addFolderRequest($evApiKey, $evAccessToken, $body = null)
    {
        // verify the required parameter 'evApiKey' is set
        if ($evApiKey === null || (is_array($evApiKey) && count($evApiKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evApiKey when calling addFolder'
            );
        }
        // verify the required parameter 'evAccessToken' is set
        if ($evAccessToken === null || (is_array($evAccessToken) && count($evAccessToken) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evAccessToken when calling addFolder'
            );
        }

        $resourcePath = '/resources';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($evApiKey !== null) {
            $headerParams['ev-api-key'] = ObjectSerializer::toHeaderValue($evApiKey);
        }
        // header params
        if ($evAccessToken !== null) {
            $headerParams['ev-access-token'] = ObjectSerializer::toHeaderValue($evAccessToken);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation compressFiles
     *
     * Compress resources
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  \ExaVault\Model\CompressFilesRequestBody $body body (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ExaVault\Model\ResourceResponse
     */
    public function compressFiles($evApiKey, $evAccessToken, $body = null)
    {
        list($response) = $this->compressFilesWithHttpInfo($evApiKey, $evAccessToken, $body);
        return $response;
    }

    /**
     * Operation compressFilesWithHttpInfo
     *
     * Compress resources
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  \ExaVault\Model\CompressFilesRequestBody $body (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ExaVault\Model\ResourceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function compressFilesWithHttpInfo($evApiKey, $evAccessToken, $body = null)
    {
        $returnType = '\ExaVault\Model\ResourceResponse';
        $request = $this->compressFilesRequest($evApiKey, $evAccessToken, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ExaVault\Model\ResourceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation compressFilesAsync
     *
     * Compress resources
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  \ExaVault\Model\CompressFilesRequestBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function compressFilesAsync($evApiKey, $evAccessToken, $body = null)
    {
        return $this->compressFilesAsyncWithHttpInfo($evApiKey, $evAccessToken, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation compressFilesAsyncWithHttpInfo
     *
     * Compress resources
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  \ExaVault\Model\CompressFilesRequestBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function compressFilesAsyncWithHttpInfo($evApiKey, $evAccessToken, $body = null)
    {
        $returnType = '\ExaVault\Model\ResourceResponse';
        $request = $this->compressFilesRequest($evApiKey, $evAccessToken, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'compressFiles'
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  \ExaVault\Model\CompressFilesRequestBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function compressFilesRequest($evApiKey, $evAccessToken, $body = null)
    {
        // verify the required parameter 'evApiKey' is set
        if ($evApiKey === null || (is_array($evApiKey) && count($evApiKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evApiKey when calling compressFiles'
            );
        }
        // verify the required parameter 'evAccessToken' is set
        if ($evAccessToken === null || (is_array($evAccessToken) && count($evAccessToken) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evAccessToken when calling compressFiles'
            );
        }

        $resourcePath = '/resources/compress';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($evApiKey !== null) {
            $headerParams['ev-api-key'] = ObjectSerializer::toHeaderValue($evApiKey);
        }
        // header params
        if ($evAccessToken !== null) {
            $headerParams['ev-access-token'] = ObjectSerializer::toHeaderValue($evAccessToken);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation copyResources
     *
     * Copy resources
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  \ExaVault\Model\CopyResourcesRequestBody $body body (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ExaVault\Model\ResourceCopyMove
     */
    public function copyResources($evApiKey, $evAccessToken, $body = null)
    {
        list($response) = $this->copyResourcesWithHttpInfo($evApiKey, $evAccessToken, $body);
        return $response;
    }

    /**
     * Operation copyResourcesWithHttpInfo
     *
     * Copy resources
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  \ExaVault\Model\CopyResourcesRequestBody $body (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ExaVault\Model\ResourceCopyMove, HTTP status code, HTTP response headers (array of strings)
     */
    public function copyResourcesWithHttpInfo($evApiKey, $evAccessToken, $body = null)
    {
        $returnType = '\ExaVault\Model\ResourceCopyMove';
        $request = $this->copyResourcesRequest($evApiKey, $evAccessToken, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ExaVault\Model\ResourceCopyMove',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 207:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ExaVault\Model\ResourceMultiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation copyResourcesAsync
     *
     * Copy resources
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  \ExaVault\Model\CopyResourcesRequestBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyResourcesAsync($evApiKey, $evAccessToken, $body = null)
    {
        return $this->copyResourcesAsyncWithHttpInfo($evApiKey, $evAccessToken, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation copyResourcesAsyncWithHttpInfo
     *
     * Copy resources
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  \ExaVault\Model\CopyResourcesRequestBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyResourcesAsyncWithHttpInfo($evApiKey, $evAccessToken, $body = null)
    {
        $returnType = '\ExaVault\Model\ResourceCopyMove';
        $request = $this->copyResourcesRequest($evApiKey, $evAccessToken, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'copyResources'
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  \ExaVault\Model\CopyResourcesRequestBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function copyResourcesRequest($evApiKey, $evAccessToken, $body = null)
    {
        // verify the required parameter 'evApiKey' is set
        if ($evApiKey === null || (is_array($evApiKey) && count($evApiKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evApiKey when calling copyResources'
            );
        }
        // verify the required parameter 'evAccessToken' is set
        if ($evAccessToken === null || (is_array($evAccessToken) && count($evAccessToken) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evAccessToken when calling copyResources'
            );
        }

        $resourcePath = '/resources/copy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($evApiKey !== null) {
            $headerParams['ev-api-key'] = ObjectSerializer::toHeaderValue($evApiKey);
        }
        // header params
        if ($evAccessToken !== null) {
            $headerParams['ev-access-token'] = ObjectSerializer::toHeaderValue($evAccessToken);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteResourceById
     *
     * Delete a Resource
     *
     * @param  int $id ID number of the resource (required)
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ExaVault\Model\EmptyResponse
     */
    public function deleteResourceById($id, $evApiKey, $evAccessToken)
    {
        list($response) = $this->deleteResourceByIdWithHttpInfo($id, $evApiKey, $evAccessToken);
        return $response;
    }

    /**
     * Operation deleteResourceByIdWithHttpInfo
     *
     * Delete a Resource
     *
     * @param  int $id ID number of the resource (required)
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ExaVault\Model\EmptyResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteResourceByIdWithHttpInfo($id, $evApiKey, $evAccessToken)
    {
        $returnType = '\ExaVault\Model\EmptyResponse';
        $request = $this->deleteResourceByIdRequest($id, $evApiKey, $evAccessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ExaVault\Model\EmptyResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteResourceByIdAsync
     *
     * Delete a Resource
     *
     * @param  int $id ID number of the resource (required)
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteResourceByIdAsync($id, $evApiKey, $evAccessToken)
    {
        return $this->deleteResourceByIdAsyncWithHttpInfo($id, $evApiKey, $evAccessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteResourceByIdAsyncWithHttpInfo
     *
     * Delete a Resource
     *
     * @param  int $id ID number of the resource (required)
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteResourceByIdAsyncWithHttpInfo($id, $evApiKey, $evAccessToken)
    {
        $returnType = '\ExaVault\Model\EmptyResponse';
        $request = $this->deleteResourceByIdRequest($id, $evApiKey, $evAccessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteResourceById'
     *
     * @param  int $id ID number of the resource (required)
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteResourceByIdRequest($id, $evApiKey, $evAccessToken)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteResourceById'
            );
        }
        // verify the required parameter 'evApiKey' is set
        if ($evApiKey === null || (is_array($evApiKey) && count($evApiKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evApiKey when calling deleteResourceById'
            );
        }
        // verify the required parameter 'evAccessToken' is set
        if ($evAccessToken === null || (is_array($evAccessToken) && count($evAccessToken) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evAccessToken when calling deleteResourceById'
            );
        }

        $resourcePath = '/resources/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($evApiKey !== null) {
            $headerParams['ev-api-key'] = ObjectSerializer::toHeaderValue($evApiKey);
        }
        // header params
        if ($evAccessToken !== null) {
            $headerParams['ev-access-token'] = ObjectSerializer::toHeaderValue($evAccessToken);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteResources
     *
     * Delete Resources
     *
     * @param  string $evApiKey API Key (required)
     * @param  string $evAccessToken Access Token (required)
     * @param  \ExaVault\Model\DeleteResourcesRequestBody $body body (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ExaVault\Model\EmptyResponse
     */
    public function deleteResources($evApiKey, $evAccessToken, $body = null)
    {
        list($response) = $this->deleteResourcesWithHttpInfo($evApiKey, $evAccessToken, $body);
        return $response;
    }

    /**
     * Operation deleteResourcesWithHttpInfo
     *
     * Delete Resources
     *
     * @param  string $evApiKey API Key (required)
     * @param  string $evAccessToken Access Token (required)
     * @param  \ExaVault\Model\DeleteResourcesRequestBody $body (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ExaVault\Model\EmptyResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteResourcesWithHttpInfo($evApiKey, $evAccessToken, $body = null)
    {
        $returnType = '\ExaVault\Model\EmptyResponse';
        $request = $this->deleteResourcesRequest($evApiKey, $evAccessToken, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ExaVault\Model\EmptyResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 207:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ExaVault\Model\ResourceMultiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteResourcesAsync
     *
     * Delete Resources
     *
     * @param  string $evApiKey API Key (required)
     * @param  string $evAccessToken Access Token (required)
     * @param  \ExaVault\Model\DeleteResourcesRequestBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteResourcesAsync($evApiKey, $evAccessToken, $body = null)
    {
        return $this->deleteResourcesAsyncWithHttpInfo($evApiKey, $evAccessToken, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteResourcesAsyncWithHttpInfo
     *
     * Delete Resources
     *
     * @param  string $evApiKey API Key (required)
     * @param  string $evAccessToken Access Token (required)
     * @param  \ExaVault\Model\DeleteResourcesRequestBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteResourcesAsyncWithHttpInfo($evApiKey, $evAccessToken, $body = null)
    {
        $returnType = '\ExaVault\Model\EmptyResponse';
        $request = $this->deleteResourcesRequest($evApiKey, $evAccessToken, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteResources'
     *
     * @param  string $evApiKey API Key (required)
     * @param  string $evAccessToken Access Token (required)
     * @param  \ExaVault\Model\DeleteResourcesRequestBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteResourcesRequest($evApiKey, $evAccessToken, $body = null)
    {
        // verify the required parameter 'evApiKey' is set
        if ($evApiKey === null || (is_array($evApiKey) && count($evApiKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evApiKey when calling deleteResources'
            );
        }
        // verify the required parameter 'evAccessToken' is set
        if ($evAccessToken === null || (is_array($evAccessToken) && count($evAccessToken) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evAccessToken when calling deleteResources'
            );
        }

        $resourcePath = '/resources';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($evApiKey !== null) {
            $headerParams['ev-api-key'] = ObjectSerializer::toHeaderValue($evApiKey);
        }
        // header params
        if ($evAccessToken !== null) {
            $headerParams['ev-access-token'] = ObjectSerializer::toHeaderValue($evAccessToken);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation download
     *
     * Download a file
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string[] $resources Path of file or folder to be downloaded, starting from the root. Can also be an array of paths. (required)
     * @param  string $downloadArchiveName If zipping multiple files, the name of the zip file to create and download. (optional)
     * @param  bool $polling Used when downloading multiple files so url will be polled till zip file is created. (optional)
     * @param  string $pollingArchiveName Reference to the previously created zip for polling operation. (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function download($evApiKey, $evAccessToken, $resources, $downloadArchiveName = null, $polling = null, $pollingArchiveName = null)
    {
        list($response) = $this->downloadWithHttpInfo($evApiKey, $evAccessToken, $resources, $downloadArchiveName, $polling, $pollingArchiveName);
        return $response;
    }

    /**
     * Operation downloadWithHttpInfo
     *
     * Download a file
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string[] $resources Path of file or folder to be downloaded, starting from the root. Can also be an array of paths. (required)
     * @param  string $downloadArchiveName If zipping multiple files, the name of the zip file to create and download. (optional)
     * @param  bool $polling Used when downloading multiple files so url will be polled till zip file is created. (optional)
     * @param  string $pollingArchiveName Reference to the previously created zip for polling operation. (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadWithHttpInfo($evApiKey, $evAccessToken, $resources, $downloadArchiveName = null, $polling = null, $pollingArchiveName = null)
    {
        $returnType = 'string';
        $request = $this->downloadRequest($evApiKey, $evAccessToken, $resources, $downloadArchiveName, $polling, $pollingArchiveName);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ExaVault\Model\DownloadPollingResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation downloadAsync
     *
     * Download a file
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string[] $resources Path of file or folder to be downloaded, starting from the root. Can also be an array of paths. (required)
     * @param  string $downloadArchiveName If zipping multiple files, the name of the zip file to create and download. (optional)
     * @param  bool $polling Used when downloading multiple files so url will be polled till zip file is created. (optional)
     * @param  string $pollingArchiveName Reference to the previously created zip for polling operation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadAsync($evApiKey, $evAccessToken, $resources, $downloadArchiveName = null, $polling = null, $pollingArchiveName = null)
    {
        return $this->downloadAsyncWithHttpInfo($evApiKey, $evAccessToken, $resources, $downloadArchiveName, $polling, $pollingArchiveName)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadAsyncWithHttpInfo
     *
     * Download a file
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string[] $resources Path of file or folder to be downloaded, starting from the root. Can also be an array of paths. (required)
     * @param  string $downloadArchiveName If zipping multiple files, the name of the zip file to create and download. (optional)
     * @param  bool $polling Used when downloading multiple files so url will be polled till zip file is created. (optional)
     * @param  string $pollingArchiveName Reference to the previously created zip for polling operation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadAsyncWithHttpInfo($evApiKey, $evAccessToken, $resources, $downloadArchiveName = null, $polling = null, $pollingArchiveName = null)
    {
        $returnType = 'string';
        $request = $this->downloadRequest($evApiKey, $evAccessToken, $resources, $downloadArchiveName, $polling, $pollingArchiveName);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'download'
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string[] $resources Path of file or folder to be downloaded, starting from the root. Can also be an array of paths. (required)
     * @param  string $downloadArchiveName If zipping multiple files, the name of the zip file to create and download. (optional)
     * @param  bool $polling Used when downloading multiple files so url will be polled till zip file is created. (optional)
     * @param  string $pollingArchiveName Reference to the previously created zip for polling operation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function downloadRequest($evApiKey, $evAccessToken, $resources, $downloadArchiveName = null, $polling = null, $pollingArchiveName = null)
    {
        // verify the required parameter 'evApiKey' is set
        if ($evApiKey === null || (is_array($evApiKey) && count($evApiKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evApiKey when calling download'
            );
        }
        // verify the required parameter 'evAccessToken' is set
        if ($evAccessToken === null || (is_array($evAccessToken) && count($evAccessToken) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evAccessToken when calling download'
            );
        }
        // verify the required parameter 'resources' is set
        if ($resources === null || (is_array($resources) && count($resources) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resources when calling download'
            );
        }

        $resourcePath = '/resources/download';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($resources)) {
            $resources = ObjectSerializer::serializeCollection($resources, 'multi', true);
        }
        if ($resources !== null) {
            $queryParams['resources[]'] = ObjectSerializer::toQueryValue($resources, null);
        }
        // query params
        if ($downloadArchiveName !== null) {
            $queryParams['downloadArchiveName'] = ObjectSerializer::toQueryValue($downloadArchiveName, null);
        }
        // query params
        if ($polling !== null) {
            $queryParams['polling'] = ObjectSerializer::toQueryValue($polling, null);
        }
        // query params
        if ($pollingArchiveName !== null) {
            $queryParams['pollingArchiveName'] = ObjectSerializer::toQueryValue($pollingArchiveName, null);
        }
        // header params
        if ($evApiKey !== null) {
            $headerParams['ev-api-key'] = ObjectSerializer::toHeaderValue($evApiKey);
        }
        // header params
        if ($evAccessToken !== null) {
            $headerParams['ev-access-token'] = ObjectSerializer::toHeaderValue($evAccessToken);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream', 'application/zip', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream', 'application/zip', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extractFiles
     *
     * Extract resources
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  \ExaVault\Model\ExtractFilesRequestBody $body body (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ExaVault\Model\ResourceCollectionResponse
     */
    public function extractFiles($evApiKey, $evAccessToken, $body = null)
    {
        list($response) = $this->extractFilesWithHttpInfo($evApiKey, $evAccessToken, $body);
        return $response;
    }

    /**
     * Operation extractFilesWithHttpInfo
     *
     * Extract resources
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  \ExaVault\Model\ExtractFilesRequestBody $body (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ExaVault\Model\ResourceCollectionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function extractFilesWithHttpInfo($evApiKey, $evAccessToken, $body = null)
    {
        $returnType = '\ExaVault\Model\ResourceCollectionResponse';
        $request = $this->extractFilesRequest($evApiKey, $evAccessToken, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ExaVault\Model\ResourceCollectionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extractFilesAsync
     *
     * Extract resources
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  \ExaVault\Model\ExtractFilesRequestBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extractFilesAsync($evApiKey, $evAccessToken, $body = null)
    {
        return $this->extractFilesAsyncWithHttpInfo($evApiKey, $evAccessToken, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extractFilesAsyncWithHttpInfo
     *
     * Extract resources
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  \ExaVault\Model\ExtractFilesRequestBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extractFilesAsyncWithHttpInfo($evApiKey, $evAccessToken, $body = null)
    {
        $returnType = '\ExaVault\Model\ResourceCollectionResponse';
        $request = $this->extractFilesRequest($evApiKey, $evAccessToken, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extractFiles'
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  \ExaVault\Model\ExtractFilesRequestBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function extractFilesRequest($evApiKey, $evAccessToken, $body = null)
    {
        // verify the required parameter 'evApiKey' is set
        if ($evApiKey === null || (is_array($evApiKey) && count($evApiKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evApiKey when calling extractFiles'
            );
        }
        // verify the required parameter 'evAccessToken' is set
        if ($evAccessToken === null || (is_array($evAccessToken) && count($evAccessToken) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evAccessToken when calling extractFiles'
            );
        }

        $resourcePath = '/resources/extract';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($evApiKey !== null) {
            $headerParams['ev-api-key'] = ObjectSerializer::toHeaderValue($evApiKey);
        }
        // header params
        if ($evAccessToken !== null) {
            $headerParams['ev-access-token'] = ObjectSerializer::toHeaderValue($evAccessToken);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPreviewImage
     *
     * Preview a file
     *
     * @param  string $evApiKey API Key (required)
     * @param  string $evAccessToken Access Token (required)
     * @param  string $resource Resource identifier for the image file. (required)
     * @param  string $size The size of the image. (required)
     * @param  int $width Overrides sizes. Sets to a specific width. (optional)
     * @param  int $height Overrides sizes. Sets to a specific height. (optional)
     * @param  int $page Page number to extract from a multi-page document (0 is the first page). Vaild for **.pdf** or **.doc** files. (optional, default to 0)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ExaVault\Model\PreviewFileResponse
     */
    public function getPreviewImage($evApiKey, $evAccessToken, $resource, $size, $width = null, $height = null, $page = '0')
    {
        list($response) = $this->getPreviewImageWithHttpInfo($evApiKey, $evAccessToken, $resource, $size, $width, $height, $page);
        return $response;
    }

    /**
     * Operation getPreviewImageWithHttpInfo
     *
     * Preview a file
     *
     * @param  string $evApiKey API Key (required)
     * @param  string $evAccessToken Access Token (required)
     * @param  string $resource Resource identifier for the image file. (required)
     * @param  string $size The size of the image. (required)
     * @param  int $width Overrides sizes. Sets to a specific width. (optional)
     * @param  int $height Overrides sizes. Sets to a specific height. (optional)
     * @param  int $page Page number to extract from a multi-page document (0 is the first page). Vaild for **.pdf** or **.doc** files. (optional, default to 0)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ExaVault\Model\PreviewFileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPreviewImageWithHttpInfo($evApiKey, $evAccessToken, $resource, $size, $width = null, $height = null, $page = '0')
    {
        $returnType = '\ExaVault\Model\PreviewFileResponse';
        $request = $this->getPreviewImageRequest($evApiKey, $evAccessToken, $resource, $size, $width, $height, $page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ExaVault\Model\PreviewFileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPreviewImageAsync
     *
     * Preview a file
     *
     * @param  string $evApiKey API Key (required)
     * @param  string $evAccessToken Access Token (required)
     * @param  string $resource Resource identifier for the image file. (required)
     * @param  string $size The size of the image. (required)
     * @param  int $width Overrides sizes. Sets to a specific width. (optional)
     * @param  int $height Overrides sizes. Sets to a specific height. (optional)
     * @param  int $page Page number to extract from a multi-page document (0 is the first page). Vaild for **.pdf** or **.doc** files. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPreviewImageAsync($evApiKey, $evAccessToken, $resource, $size, $width = null, $height = null, $page = '0')
    {
        return $this->getPreviewImageAsyncWithHttpInfo($evApiKey, $evAccessToken, $resource, $size, $width, $height, $page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPreviewImageAsyncWithHttpInfo
     *
     * Preview a file
     *
     * @param  string $evApiKey API Key (required)
     * @param  string $evAccessToken Access Token (required)
     * @param  string $resource Resource identifier for the image file. (required)
     * @param  string $size The size of the image. (required)
     * @param  int $width Overrides sizes. Sets to a specific width. (optional)
     * @param  int $height Overrides sizes. Sets to a specific height. (optional)
     * @param  int $page Page number to extract from a multi-page document (0 is the first page). Vaild for **.pdf** or **.doc** files. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPreviewImageAsyncWithHttpInfo($evApiKey, $evAccessToken, $resource, $size, $width = null, $height = null, $page = '0')
    {
        $returnType = '\ExaVault\Model\PreviewFileResponse';
        $request = $this->getPreviewImageRequest($evApiKey, $evAccessToken, $resource, $size, $width, $height, $page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPreviewImage'
     *
     * @param  string $evApiKey API Key (required)
     * @param  string $evAccessToken Access Token (required)
     * @param  string $resource Resource identifier for the image file. (required)
     * @param  string $size The size of the image. (required)
     * @param  int $width Overrides sizes. Sets to a specific width. (optional)
     * @param  int $height Overrides sizes. Sets to a specific height. (optional)
     * @param  int $page Page number to extract from a multi-page document (0 is the first page). Vaild for **.pdf** or **.doc** files. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPreviewImageRequest($evApiKey, $evAccessToken, $resource, $size, $width = null, $height = null, $page = '0')
    {
        // verify the required parameter 'evApiKey' is set
        if ($evApiKey === null || (is_array($evApiKey) && count($evApiKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evApiKey when calling getPreviewImage'
            );
        }
        // verify the required parameter 'evAccessToken' is set
        if ($evAccessToken === null || (is_array($evAccessToken) && count($evAccessToken) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evAccessToken when calling getPreviewImage'
            );
        }
        // verify the required parameter 'resource' is set
        if ($resource === null || (is_array($resource) && count($resource) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource when calling getPreviewImage'
            );
        }
        // verify the required parameter 'size' is set
        if ($size === null || (is_array($size) && count($size) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $size when calling getPreviewImage'
            );
        }

        $resourcePath = '/resources/preview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($resource !== null) {
            $queryParams['resource'] = ObjectSerializer::toQueryValue($resource, null);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size, null);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width, 'int32');
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height, 'int32');
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // header params
        if ($evApiKey !== null) {
            $headerParams['ev-api-key'] = ObjectSerializer::toHeaderValue($evApiKey);
        }
        // header params
        if ($evAccessToken !== null) {
            $headerParams['ev-access-token'] = ObjectSerializer::toHeaderValue($evAccessToken);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getResourceInfo
     *
     * Get Resource Properties
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $resource Resource identifier of the file or folder to get metadata for. (required)
     * @param  string $include Comma separated list of relationships to include in response. Possible values are **share**, **notifications**, **directFile**, **parentResource**, **ownerUser**, **ownerUser**. (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ExaVault\Model\ResourceResponse
     */
    public function getResourceInfo($evApiKey, $evAccessToken, $resource, $include = null)
    {
        list($response) = $this->getResourceInfoWithHttpInfo($evApiKey, $evAccessToken, $resource, $include);
        return $response;
    }

    /**
     * Operation getResourceInfoWithHttpInfo
     *
     * Get Resource Properties
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $resource Resource identifier of the file or folder to get metadata for. (required)
     * @param  string $include Comma separated list of relationships to include in response. Possible values are **share**, **notifications**, **directFile**, **parentResource**, **ownerUser**, **ownerUser**. (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ExaVault\Model\ResourceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getResourceInfoWithHttpInfo($evApiKey, $evAccessToken, $resource, $include = null)
    {
        $returnType = '\ExaVault\Model\ResourceResponse';
        $request = $this->getResourceInfoRequest($evApiKey, $evAccessToken, $resource, $include);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ExaVault\Model\ResourceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getResourceInfoAsync
     *
     * Get Resource Properties
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $resource Resource identifier of the file or folder to get metadata for. (required)
     * @param  string $include Comma separated list of relationships to include in response. Possible values are **share**, **notifications**, **directFile**, **parentResource**, **ownerUser**, **ownerUser**. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getResourceInfoAsync($evApiKey, $evAccessToken, $resource, $include = null)
    {
        return $this->getResourceInfoAsyncWithHttpInfo($evApiKey, $evAccessToken, $resource, $include)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getResourceInfoAsyncWithHttpInfo
     *
     * Get Resource Properties
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $resource Resource identifier of the file or folder to get metadata for. (required)
     * @param  string $include Comma separated list of relationships to include in response. Possible values are **share**, **notifications**, **directFile**, **parentResource**, **ownerUser**, **ownerUser**. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getResourceInfoAsyncWithHttpInfo($evApiKey, $evAccessToken, $resource, $include = null)
    {
        $returnType = '\ExaVault\Model\ResourceResponse';
        $request = $this->getResourceInfoRequest($evApiKey, $evAccessToken, $resource, $include);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getResourceInfo'
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $resource Resource identifier of the file or folder to get metadata for. (required)
     * @param  string $include Comma separated list of relationships to include in response. Possible values are **share**, **notifications**, **directFile**, **parentResource**, **ownerUser**, **ownerUser**. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getResourceInfoRequest($evApiKey, $evAccessToken, $resource, $include = null)
    {
        // verify the required parameter 'evApiKey' is set
        if ($evApiKey === null || (is_array($evApiKey) && count($evApiKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evApiKey when calling getResourceInfo'
            );
        }
        // verify the required parameter 'evAccessToken' is set
        if ($evAccessToken === null || (is_array($evAccessToken) && count($evAccessToken) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evAccessToken when calling getResourceInfo'
            );
        }
        // verify the required parameter 'resource' is set
        if ($resource === null || (is_array($resource) && count($resource) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource when calling getResourceInfo'
            );
        }

        $resourcePath = '/resources';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($resource !== null) {
            $queryParams['resource'] = ObjectSerializer::toQueryValue($resource, null);
        }
        // query params
        if ($include !== null) {
            $queryParams['include'] = ObjectSerializer::toQueryValue($include, null);
        }
        // header params
        if ($evApiKey !== null) {
            $headerParams['ev-api-key'] = ObjectSerializer::toHeaderValue($evApiKey);
        }
        // header params
        if ($evAccessToken !== null) {
            $headerParams['ev-access-token'] = ObjectSerializer::toHeaderValue($evAccessToken);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getResourceInfoById
     *
     * Get resource metadata
     *
     * @param  int $id ID number of the resource (required)
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $include Comma separated list of relationships to include in response. Possible values are **share**, **notifications**, **directFile**, **parentResource**, **ownerUser**, **ownerAccount**. (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ExaVault\Model\ResourceResponse
     */
    public function getResourceInfoById($id, $evApiKey, $evAccessToken, $include = null)
    {
        list($response) = $this->getResourceInfoByIdWithHttpInfo($id, $evApiKey, $evAccessToken, $include);
        return $response;
    }

    /**
     * Operation getResourceInfoByIdWithHttpInfo
     *
     * Get resource metadata
     *
     * @param  int $id ID number of the resource (required)
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $include Comma separated list of relationships to include in response. Possible values are **share**, **notifications**, **directFile**, **parentResource**, **ownerUser**, **ownerAccount**. (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ExaVault\Model\ResourceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getResourceInfoByIdWithHttpInfo($id, $evApiKey, $evAccessToken, $include = null)
    {
        $returnType = '\ExaVault\Model\ResourceResponse';
        $request = $this->getResourceInfoByIdRequest($id, $evApiKey, $evAccessToken, $include);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ExaVault\Model\ResourceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getResourceInfoByIdAsync
     *
     * Get resource metadata
     *
     * @param  int $id ID number of the resource (required)
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $include Comma separated list of relationships to include in response. Possible values are **share**, **notifications**, **directFile**, **parentResource**, **ownerUser**, **ownerAccount**. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getResourceInfoByIdAsync($id, $evApiKey, $evAccessToken, $include = null)
    {
        return $this->getResourceInfoByIdAsyncWithHttpInfo($id, $evApiKey, $evAccessToken, $include)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getResourceInfoByIdAsyncWithHttpInfo
     *
     * Get resource metadata
     *
     * @param  int $id ID number of the resource (required)
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $include Comma separated list of relationships to include in response. Possible values are **share**, **notifications**, **directFile**, **parentResource**, **ownerUser**, **ownerAccount**. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getResourceInfoByIdAsyncWithHttpInfo($id, $evApiKey, $evAccessToken, $include = null)
    {
        $returnType = '\ExaVault\Model\ResourceResponse';
        $request = $this->getResourceInfoByIdRequest($id, $evApiKey, $evAccessToken, $include);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getResourceInfoById'
     *
     * @param  int $id ID number of the resource (required)
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $include Comma separated list of relationships to include in response. Possible values are **share**, **notifications**, **directFile**, **parentResource**, **ownerUser**, **ownerAccount**. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getResourceInfoByIdRequest($id, $evApiKey, $evAccessToken, $include = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getResourceInfoById'
            );
        }
        // verify the required parameter 'evApiKey' is set
        if ($evApiKey === null || (is_array($evApiKey) && count($evApiKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evApiKey when calling getResourceInfoById'
            );
        }
        // verify the required parameter 'evAccessToken' is set
        if ($evAccessToken === null || (is_array($evAccessToken) && count($evAccessToken) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evAccessToken when calling getResourceInfoById'
            );
        }

        $resourcePath = '/resources/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include !== null) {
            $queryParams['include'] = ObjectSerializer::toQueryValue($include, null);
        }
        // header params
        if ($evApiKey !== null) {
            $headerParams['ev-api-key'] = ObjectSerializer::toHeaderValue($evApiKey);
        }
        // header params
        if ($evAccessToken !== null) {
            $headerParams['ev-access-token'] = ObjectSerializer::toHeaderValue($evAccessToken);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listResourceContents
     *
     * List contents of folder
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  int $id ID of the parent resource to get a list of resources for. (required)
     * @param  string $sort Endpoint support multiple sort fields by allowing array of sort params. Sort fields should be applied in the order specified. The sort order for each sort field is ascending unless it is prefixed with a minus (-), in which case it will be descending. (optional)
     * @param  int $offset Determines which item to start on for pagination. Use zero (0) to start at the beginning of the list. (optional, default to 0)
     * @param  int $limit The number of files to limit the result. Cannot be set higher than 100. If you have more than one hundred files in your directory, make multiple calls, incrementing the &#x60;offset parameter, above. (optional)
     * @param  string $type Limit types of resources returned to \&quot;file\&quot; or \&quot;dir\&quot; only. (optional)
     * @param  string $include Comma separated list of relationships to include in response. Possible values are **share**, **notifications**, **directFile**, **parentResource**, **ownerUser**, **ownerUser**. (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ExaVault\Model\ResourceCollectionResponse
     */
    public function listResourceContents($evApiKey, $evAccessToken, $id, $sort = null, $offset = '0', $limit = null, $type = null, $include = null)
    {
        list($response) = $this->listResourceContentsWithHttpInfo($evApiKey, $evAccessToken, $id, $sort, $offset, $limit, $type, $include);
        return $response;
    }

    /**
     * Operation listResourceContentsWithHttpInfo
     *
     * List contents of folder
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  int $id ID of the parent resource to get a list of resources for. (required)
     * @param  string $sort Endpoint support multiple sort fields by allowing array of sort params. Sort fields should be applied in the order specified. The sort order for each sort field is ascending unless it is prefixed with a minus (-), in which case it will be descending. (optional)
     * @param  int $offset Determines which item to start on for pagination. Use zero (0) to start at the beginning of the list. (optional, default to 0)
     * @param  int $limit The number of files to limit the result. Cannot be set higher than 100. If you have more than one hundred files in your directory, make multiple calls, incrementing the &#x60;offset parameter, above. (optional)
     * @param  string $type Limit types of resources returned to \&quot;file\&quot; or \&quot;dir\&quot; only. (optional)
     * @param  string $include Comma separated list of relationships to include in response. Possible values are **share**, **notifications**, **directFile**, **parentResource**, **ownerUser**, **ownerUser**. (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ExaVault\Model\ResourceCollectionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listResourceContentsWithHttpInfo($evApiKey, $evAccessToken, $id, $sort = null, $offset = '0', $limit = null, $type = null, $include = null)
    {
        $returnType = '\ExaVault\Model\ResourceCollectionResponse';
        $request = $this->listResourceContentsRequest($evApiKey, $evAccessToken, $id, $sort, $offset, $limit, $type, $include);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ExaVault\Model\ResourceCollectionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listResourceContentsAsync
     *
     * List contents of folder
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  int $id ID of the parent resource to get a list of resources for. (required)
     * @param  string $sort Endpoint support multiple sort fields by allowing array of sort params. Sort fields should be applied in the order specified. The sort order for each sort field is ascending unless it is prefixed with a minus (-), in which case it will be descending. (optional)
     * @param  int $offset Determines which item to start on for pagination. Use zero (0) to start at the beginning of the list. (optional, default to 0)
     * @param  int $limit The number of files to limit the result. Cannot be set higher than 100. If you have more than one hundred files in your directory, make multiple calls, incrementing the &#x60;offset parameter, above. (optional)
     * @param  string $type Limit types of resources returned to \&quot;file\&quot; or \&quot;dir\&quot; only. (optional)
     * @param  string $include Comma separated list of relationships to include in response. Possible values are **share**, **notifications**, **directFile**, **parentResource**, **ownerUser**, **ownerUser**. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listResourceContentsAsync($evApiKey, $evAccessToken, $id, $sort = null, $offset = '0', $limit = null, $type = null, $include = null)
    {
        return $this->listResourceContentsAsyncWithHttpInfo($evApiKey, $evAccessToken, $id, $sort, $offset, $limit, $type, $include)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listResourceContentsAsyncWithHttpInfo
     *
     * List contents of folder
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  int $id ID of the parent resource to get a list of resources for. (required)
     * @param  string $sort Endpoint support multiple sort fields by allowing array of sort params. Sort fields should be applied in the order specified. The sort order for each sort field is ascending unless it is prefixed with a minus (-), in which case it will be descending. (optional)
     * @param  int $offset Determines which item to start on for pagination. Use zero (0) to start at the beginning of the list. (optional, default to 0)
     * @param  int $limit The number of files to limit the result. Cannot be set higher than 100. If you have more than one hundred files in your directory, make multiple calls, incrementing the &#x60;offset parameter, above. (optional)
     * @param  string $type Limit types of resources returned to \&quot;file\&quot; or \&quot;dir\&quot; only. (optional)
     * @param  string $include Comma separated list of relationships to include in response. Possible values are **share**, **notifications**, **directFile**, **parentResource**, **ownerUser**, **ownerUser**. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listResourceContentsAsyncWithHttpInfo($evApiKey, $evAccessToken, $id, $sort = null, $offset = '0', $limit = null, $type = null, $include = null)
    {
        $returnType = '\ExaVault\Model\ResourceCollectionResponse';
        $request = $this->listResourceContentsRequest($evApiKey, $evAccessToken, $id, $sort, $offset, $limit, $type, $include);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listResourceContents'
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  int $id ID of the parent resource to get a list of resources for. (required)
     * @param  string $sort Endpoint support multiple sort fields by allowing array of sort params. Sort fields should be applied in the order specified. The sort order for each sort field is ascending unless it is prefixed with a minus (-), in which case it will be descending. (optional)
     * @param  int $offset Determines which item to start on for pagination. Use zero (0) to start at the beginning of the list. (optional, default to 0)
     * @param  int $limit The number of files to limit the result. Cannot be set higher than 100. If you have more than one hundred files in your directory, make multiple calls, incrementing the &#x60;offset parameter, above. (optional)
     * @param  string $type Limit types of resources returned to \&quot;file\&quot; or \&quot;dir\&quot; only. (optional)
     * @param  string $include Comma separated list of relationships to include in response. Possible values are **share**, **notifications**, **directFile**, **parentResource**, **ownerUser**, **ownerUser**. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listResourceContentsRequest($evApiKey, $evAccessToken, $id, $sort = null, $offset = '0', $limit = null, $type = null, $include = null)
    {
        // verify the required parameter 'evApiKey' is set
        if ($evApiKey === null || (is_array($evApiKey) && count($evApiKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evApiKey when calling listResourceContents'
            );
        }
        // verify the required parameter 'evAccessToken' is set
        if ($evAccessToken === null || (is_array($evAccessToken) && count($evAccessToken) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evAccessToken when calling listResourceContents'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling listResourceContents'
            );
        }

        $resourcePath = '/resources/list/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, 'int32');
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, 'int32');
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type, null);
        }
        // query params
        if ($include !== null) {
            $queryParams['include'] = ObjectSerializer::toQueryValue($include, null);
        }
        // header params
        if ($evApiKey !== null) {
            $headerParams['ev-api-key'] = ObjectSerializer::toHeaderValue($evApiKey);
        }
        // header params
        if ($evAccessToken !== null) {
            $headerParams['ev-access-token'] = ObjectSerializer::toHeaderValue($evAccessToken);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listResources
     *
     * Get a list of all resources
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $resource Resource identifier to get resources for. Can be path/id/name. (required)
     * @param  string $sort Endpoint support multiple sort fields by allowing array of sort params. Sort fields should be applied in the order specified. The sort order for each sort field is ascending unless it is prefixed with a minus (-), in which case it will be descending. (optional)
     * @param  int $offset Determines which item to start on for pagination. Use zero (0) to start at the beginning of the list. (optional, default to 0)
     * @param  int $limit The number of files to limit the result. Cannot be set higher than 100. If you have more than one hundred files in your directory, make multiple calls, incrementing the &#x60;offset&#x60; parameter, above. (optional)
     * @param  string $type Limit types of resources returned to \&quot;file\&quot; or \&quot;dir\&quot; only. This is ignored if you are using the name parameter to trigger a search. (optional)
     * @param  string $name Text to match resource names. This allows you to filter the results returned. For example, to locate only zip archive files, you can enter &#x60;*zip&#x60; and only resources ending in \&quot;zip\&quot; will be included in the list of results. (optional)
     * @param  string $include Comma separated list of relationships to include in response. Possible values are **share**, **notifications**, **directFile**, **parentResource**, **ownerUser**, **ownerAccount**. (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ExaVault\Model\ResourceCollectionResponse
     */
    public function listResources($evApiKey, $evAccessToken, $resource, $sort = null, $offset = '0', $limit = null, $type = null, $name = null, $include = null)
    {
        list($response) = $this->listResourcesWithHttpInfo($evApiKey, $evAccessToken, $resource, $sort, $offset, $limit, $type, $name, $include);
        return $response;
    }

    /**
     * Operation listResourcesWithHttpInfo
     *
     * Get a list of all resources
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $resource Resource identifier to get resources for. Can be path/id/name. (required)
     * @param  string $sort Endpoint support multiple sort fields by allowing array of sort params. Sort fields should be applied in the order specified. The sort order for each sort field is ascending unless it is prefixed with a minus (-), in which case it will be descending. (optional)
     * @param  int $offset Determines which item to start on for pagination. Use zero (0) to start at the beginning of the list. (optional, default to 0)
     * @param  int $limit The number of files to limit the result. Cannot be set higher than 100. If you have more than one hundred files in your directory, make multiple calls, incrementing the &#x60;offset&#x60; parameter, above. (optional)
     * @param  string $type Limit types of resources returned to \&quot;file\&quot; or \&quot;dir\&quot; only. This is ignored if you are using the name parameter to trigger a search. (optional)
     * @param  string $name Text to match resource names. This allows you to filter the results returned. For example, to locate only zip archive files, you can enter &#x60;*zip&#x60; and only resources ending in \&quot;zip\&quot; will be included in the list of results. (optional)
     * @param  string $include Comma separated list of relationships to include in response. Possible values are **share**, **notifications**, **directFile**, **parentResource**, **ownerUser**, **ownerAccount**. (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ExaVault\Model\ResourceCollectionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listResourcesWithHttpInfo($evApiKey, $evAccessToken, $resource, $sort = null, $offset = '0', $limit = null, $type = null, $name = null, $include = null)
    {
        $returnType = '\ExaVault\Model\ResourceCollectionResponse';
        $request = $this->listResourcesRequest($evApiKey, $evAccessToken, $resource, $sort, $offset, $limit, $type, $name, $include);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ExaVault\Model\ResourceCollectionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listResourcesAsync
     *
     * Get a list of all resources
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $resource Resource identifier to get resources for. Can be path/id/name. (required)
     * @param  string $sort Endpoint support multiple sort fields by allowing array of sort params. Sort fields should be applied in the order specified. The sort order for each sort field is ascending unless it is prefixed with a minus (-), in which case it will be descending. (optional)
     * @param  int $offset Determines which item to start on for pagination. Use zero (0) to start at the beginning of the list. (optional, default to 0)
     * @param  int $limit The number of files to limit the result. Cannot be set higher than 100. If you have more than one hundred files in your directory, make multiple calls, incrementing the &#x60;offset&#x60; parameter, above. (optional)
     * @param  string $type Limit types of resources returned to \&quot;file\&quot; or \&quot;dir\&quot; only. This is ignored if you are using the name parameter to trigger a search. (optional)
     * @param  string $name Text to match resource names. This allows you to filter the results returned. For example, to locate only zip archive files, you can enter &#x60;*zip&#x60; and only resources ending in \&quot;zip\&quot; will be included in the list of results. (optional)
     * @param  string $include Comma separated list of relationships to include in response. Possible values are **share**, **notifications**, **directFile**, **parentResource**, **ownerUser**, **ownerAccount**. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listResourcesAsync($evApiKey, $evAccessToken, $resource, $sort = null, $offset = '0', $limit = null, $type = null, $name = null, $include = null)
    {
        return $this->listResourcesAsyncWithHttpInfo($evApiKey, $evAccessToken, $resource, $sort, $offset, $limit, $type, $name, $include)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listResourcesAsyncWithHttpInfo
     *
     * Get a list of all resources
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $resource Resource identifier to get resources for. Can be path/id/name. (required)
     * @param  string $sort Endpoint support multiple sort fields by allowing array of sort params. Sort fields should be applied in the order specified. The sort order for each sort field is ascending unless it is prefixed with a minus (-), in which case it will be descending. (optional)
     * @param  int $offset Determines which item to start on for pagination. Use zero (0) to start at the beginning of the list. (optional, default to 0)
     * @param  int $limit The number of files to limit the result. Cannot be set higher than 100. If you have more than one hundred files in your directory, make multiple calls, incrementing the &#x60;offset&#x60; parameter, above. (optional)
     * @param  string $type Limit types of resources returned to \&quot;file\&quot; or \&quot;dir\&quot; only. This is ignored if you are using the name parameter to trigger a search. (optional)
     * @param  string $name Text to match resource names. This allows you to filter the results returned. For example, to locate only zip archive files, you can enter &#x60;*zip&#x60; and only resources ending in \&quot;zip\&quot; will be included in the list of results. (optional)
     * @param  string $include Comma separated list of relationships to include in response. Possible values are **share**, **notifications**, **directFile**, **parentResource**, **ownerUser**, **ownerAccount**. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listResourcesAsyncWithHttpInfo($evApiKey, $evAccessToken, $resource, $sort = null, $offset = '0', $limit = null, $type = null, $name = null, $include = null)
    {
        $returnType = '\ExaVault\Model\ResourceCollectionResponse';
        $request = $this->listResourcesRequest($evApiKey, $evAccessToken, $resource, $sort, $offset, $limit, $type, $name, $include);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listResources'
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $resource Resource identifier to get resources for. Can be path/id/name. (required)
     * @param  string $sort Endpoint support multiple sort fields by allowing array of sort params. Sort fields should be applied in the order specified. The sort order for each sort field is ascending unless it is prefixed with a minus (-), in which case it will be descending. (optional)
     * @param  int $offset Determines which item to start on for pagination. Use zero (0) to start at the beginning of the list. (optional, default to 0)
     * @param  int $limit The number of files to limit the result. Cannot be set higher than 100. If you have more than one hundred files in your directory, make multiple calls, incrementing the &#x60;offset&#x60; parameter, above. (optional)
     * @param  string $type Limit types of resources returned to \&quot;file\&quot; or \&quot;dir\&quot; only. This is ignored if you are using the name parameter to trigger a search. (optional)
     * @param  string $name Text to match resource names. This allows you to filter the results returned. For example, to locate only zip archive files, you can enter &#x60;*zip&#x60; and only resources ending in \&quot;zip\&quot; will be included in the list of results. (optional)
     * @param  string $include Comma separated list of relationships to include in response. Possible values are **share**, **notifications**, **directFile**, **parentResource**, **ownerUser**, **ownerAccount**. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listResourcesRequest($evApiKey, $evAccessToken, $resource, $sort = null, $offset = '0', $limit = null, $type = null, $name = null, $include = null)
    {
        // verify the required parameter 'evApiKey' is set
        if ($evApiKey === null || (is_array($evApiKey) && count($evApiKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evApiKey when calling listResources'
            );
        }
        // verify the required parameter 'evAccessToken' is set
        if ($evAccessToken === null || (is_array($evAccessToken) && count($evAccessToken) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evAccessToken when calling listResources'
            );
        }
        // verify the required parameter 'resource' is set
        if ($resource === null || (is_array($resource) && count($resource) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource when calling listResources'
            );
        }

        $resourcePath = '/resources/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($resource !== null) {
            $queryParams['resource'] = ObjectSerializer::toQueryValue($resource, null);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, 'int32');
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, 'int32');
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type, null);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name, null);
        }
        // query params
        if ($include !== null) {
            $queryParams['include'] = ObjectSerializer::toQueryValue($include, null);
        }
        // header params
        if ($evApiKey !== null) {
            $headerParams['ev-api-key'] = ObjectSerializer::toHeaderValue($evApiKey);
        }
        // header params
        if ($evAccessToken !== null) {
            $headerParams['ev-access-token'] = ObjectSerializer::toHeaderValue($evAccessToken);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation moveResources
     *
     * Move resources
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  \ExaVault\Model\MoveResourcesRequestBody $body body (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ExaVault\Model\ResourceCopyMove
     */
    public function moveResources($evApiKey, $evAccessToken, $body = null)
    {
        list($response) = $this->moveResourcesWithHttpInfo($evApiKey, $evAccessToken, $body);
        return $response;
    }

    /**
     * Operation moveResourcesWithHttpInfo
     *
     * Move resources
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  \ExaVault\Model\MoveResourcesRequestBody $body (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ExaVault\Model\ResourceCopyMove, HTTP status code, HTTP response headers (array of strings)
     */
    public function moveResourcesWithHttpInfo($evApiKey, $evAccessToken, $body = null)
    {
        $returnType = '\ExaVault\Model\ResourceCopyMove';
        $request = $this->moveResourcesRequest($evApiKey, $evAccessToken, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ExaVault\Model\ResourceCopyMove',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 207:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ExaVault\Model\ResourceMultiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation moveResourcesAsync
     *
     * Move resources
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  \ExaVault\Model\MoveResourcesRequestBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function moveResourcesAsync($evApiKey, $evAccessToken, $body = null)
    {
        return $this->moveResourcesAsyncWithHttpInfo($evApiKey, $evAccessToken, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation moveResourcesAsyncWithHttpInfo
     *
     * Move resources
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  \ExaVault\Model\MoveResourcesRequestBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function moveResourcesAsyncWithHttpInfo($evApiKey, $evAccessToken, $body = null)
    {
        $returnType = '\ExaVault\Model\ResourceCopyMove';
        $request = $this->moveResourcesRequest($evApiKey, $evAccessToken, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'moveResources'
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  \ExaVault\Model\MoveResourcesRequestBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function moveResourcesRequest($evApiKey, $evAccessToken, $body = null)
    {
        // verify the required parameter 'evApiKey' is set
        if ($evApiKey === null || (is_array($evApiKey) && count($evApiKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evApiKey when calling moveResources'
            );
        }
        // verify the required parameter 'evAccessToken' is set
        if ($evAccessToken === null || (is_array($evAccessToken) && count($evAccessToken) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evAccessToken when calling moveResources'
            );
        }

        $resourcePath = '/resources/move';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($evApiKey !== null) {
            $headerParams['ev-api-key'] = ObjectSerializer::toHeaderValue($evApiKey);
        }
        // header params
        if ($evAccessToken !== null) {
            $headerParams['ev-access-token'] = ObjectSerializer::toHeaderValue($evAccessToken);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateResourceById
     *
     * Rename a resource.
     *
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $evApiKey API key required to make the API call. (required)
     * @param  int $id ID number of the resource (required)
     * @param  \ExaVault\Model\UpdateReourceByIdRequestBody $body body (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ExaVault\Model\ResourceResponse
     */
    public function updateResourceById($evAccessToken, $evApiKey, $id, $body = null)
    {
        list($response) = $this->updateResourceByIdWithHttpInfo($evAccessToken, $evApiKey, $id, $body);
        return $response;
    }

    /**
     * Operation updateResourceByIdWithHttpInfo
     *
     * Rename a resource.
     *
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $evApiKey API key required to make the API call. (required)
     * @param  int $id ID number of the resource (required)
     * @param  \ExaVault\Model\UpdateReourceByIdRequestBody $body (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ExaVault\Model\ResourceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateResourceByIdWithHttpInfo($evAccessToken, $evApiKey, $id, $body = null)
    {
        $returnType = '\ExaVault\Model\ResourceResponse';
        $request = $this->updateResourceByIdRequest($evAccessToken, $evApiKey, $id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ExaVault\Model\ResourceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateResourceByIdAsync
     *
     * Rename a resource.
     *
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $evApiKey API key required to make the API call. (required)
     * @param  int $id ID number of the resource (required)
     * @param  \ExaVault\Model\UpdateReourceByIdRequestBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateResourceByIdAsync($evAccessToken, $evApiKey, $id, $body = null)
    {
        return $this->updateResourceByIdAsyncWithHttpInfo($evAccessToken, $evApiKey, $id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateResourceByIdAsyncWithHttpInfo
     *
     * Rename a resource.
     *
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $evApiKey API key required to make the API call. (required)
     * @param  int $id ID number of the resource (required)
     * @param  \ExaVault\Model\UpdateReourceByIdRequestBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateResourceByIdAsyncWithHttpInfo($evAccessToken, $evApiKey, $id, $body = null)
    {
        $returnType = '\ExaVault\Model\ResourceResponse';
        $request = $this->updateResourceByIdRequest($evAccessToken, $evApiKey, $id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateResourceById'
     *
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $evApiKey API key required to make the API call. (required)
     * @param  int $id ID number of the resource (required)
     * @param  \ExaVault\Model\UpdateReourceByIdRequestBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateResourceByIdRequest($evAccessToken, $evApiKey, $id, $body = null)
    {
        // verify the required parameter 'evAccessToken' is set
        if ($evAccessToken === null || (is_array($evAccessToken) && count($evAccessToken) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evAccessToken when calling updateResourceById'
            );
        }
        // verify the required parameter 'evApiKey' is set
        if ($evApiKey === null || (is_array($evApiKey) && count($evApiKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evApiKey when calling updateResourceById'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateResourceById'
            );
        }

        $resourcePath = '/resources/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($evAccessToken !== null) {
            $headerParams['ev-access-token'] = ObjectSerializer::toHeaderValue($evAccessToken);
        }
        // header params
        if ($evApiKey !== null) {
            $headerParams['ev-api-key'] = ObjectSerializer::toHeaderValue($evApiKey);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadFile
     *
     * Upload a file
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $path Destination path for the file being uploaded, including the file name. (required)
     * @param  int $fileSize File size, in bits, of the file being uploaded. (required)
     * @param  string $file file (optional)
     * @param  int $offsetBytes Allows a file upload to resume at a certain number of bytes. (optional)
     * @param  bool $resume True if upload resume is supported, false if it isn&#x27;t. (optional, default to true)
     * @param  bool $allowOverwrite True if a file with the same name is found in the designated path, should be overwritten. False if different file names should be generated. (optional, default to false)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ExaVault\Model\ResourceResponse
     */
    public function uploadFile($evApiKey, $evAccessToken, $path, $fileSize, $file = null, $offsetBytes = null, $resume = 'true', $allowOverwrite = 'false')
    {
        list($response) = $this->uploadFileWithHttpInfo($evApiKey, $evAccessToken, $path, $fileSize, $file, $offsetBytes, $resume, $allowOverwrite);
        return $response;
    }

    /**
     * Operation uploadFileWithHttpInfo
     *
     * Upload a file
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $path Destination path for the file being uploaded, including the file name. (required)
     * @param  int $fileSize File size, in bits, of the file being uploaded. (required)
     * @param  string $file (optional)
     * @param  int $offsetBytes Allows a file upload to resume at a certain number of bytes. (optional)
     * @param  bool $resume True if upload resume is supported, false if it isn&#x27;t. (optional, default to true)
     * @param  bool $allowOverwrite True if a file with the same name is found in the designated path, should be overwritten. False if different file names should be generated. (optional, default to false)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ExaVault\Model\ResourceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadFileWithHttpInfo($evApiKey, $evAccessToken, $path, $fileSize, $file = null, $offsetBytes = null, $resume = 'true', $allowOverwrite = 'false')
    {
        $returnType = '\ExaVault\Model\ResourceResponse';
        $request = $this->uploadFileRequest($evApiKey, $evAccessToken, $path, $fileSize, $file, $offsetBytes, $resume, $allowOverwrite);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ExaVault\Model\ResourceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation uploadFileAsync
     *
     * Upload a file
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $path Destination path for the file being uploaded, including the file name. (required)
     * @param  int $fileSize File size, in bits, of the file being uploaded. (required)
     * @param  string $file (optional)
     * @param  int $offsetBytes Allows a file upload to resume at a certain number of bytes. (optional)
     * @param  bool $resume True if upload resume is supported, false if it isn&#x27;t. (optional, default to true)
     * @param  bool $allowOverwrite True if a file with the same name is found in the designated path, should be overwritten. False if different file names should be generated. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadFileAsync($evApiKey, $evAccessToken, $path, $fileSize, $file = null, $offsetBytes = null, $resume = 'true', $allowOverwrite = 'false')
    {
        return $this->uploadFileAsyncWithHttpInfo($evApiKey, $evAccessToken, $path, $fileSize, $file, $offsetBytes, $resume, $allowOverwrite)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadFileAsyncWithHttpInfo
     *
     * Upload a file
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $path Destination path for the file being uploaded, including the file name. (required)
     * @param  int $fileSize File size, in bits, of the file being uploaded. (required)
     * @param  string $file (optional)
     * @param  int $offsetBytes Allows a file upload to resume at a certain number of bytes. (optional)
     * @param  bool $resume True if upload resume is supported, false if it isn&#x27;t. (optional, default to true)
     * @param  bool $allowOverwrite True if a file with the same name is found in the designated path, should be overwritten. False if different file names should be generated. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadFileAsyncWithHttpInfo($evApiKey, $evAccessToken, $path, $fileSize, $file = null, $offsetBytes = null, $resume = 'true', $allowOverwrite = 'false')
    {
        $returnType = '\ExaVault\Model\ResourceResponse';
        $request = $this->uploadFileRequest($evApiKey, $evAccessToken, $path, $fileSize, $file, $offsetBytes, $resume, $allowOverwrite);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadFile'
     *
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $path Destination path for the file being uploaded, including the file name. (required)
     * @param  int $fileSize File size, in bits, of the file being uploaded. (required)
     * @param  string $file (optional)
     * @param  int $offsetBytes Allows a file upload to resume at a certain number of bytes. (optional)
     * @param  bool $resume True if upload resume is supported, false if it isn&#x27;t. (optional, default to true)
     * @param  bool $allowOverwrite True if a file with the same name is found in the designated path, should be overwritten. False if different file names should be generated. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function uploadFileRequest($evApiKey, $evAccessToken, $path, $fileSize, $file = null, $offsetBytes = null, $resume = 'true', $allowOverwrite = 'false')
    {
        // verify the required parameter 'evApiKey' is set
        if ($evApiKey === null || (is_array($evApiKey) && count($evApiKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evApiKey when calling uploadFile'
            );
        }
        // verify the required parameter 'evAccessToken' is set
        if ($evAccessToken === null || (is_array($evAccessToken) && count($evAccessToken) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evAccessToken when calling uploadFile'
            );
        }
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling uploadFile'
            );
        }
        // verify the required parameter 'fileSize' is set
        if ($fileSize === null || (is_array($fileSize) && count($fileSize) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fileSize when calling uploadFile'
            );
        }

        $resourcePath = '/resources/upload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path, null);
        }
        // query params
        if ($fileSize !== null) {
            $queryParams['fileSize'] = ObjectSerializer::toQueryValue($fileSize, null);
        }
        // query params
        if ($resume !== null) {
            $queryParams['resume'] = ObjectSerializer::toQueryValue($resume, null);
        }
        // query params
        if ($allowOverwrite !== null) {
            $queryParams['allowOverwrite'] = ObjectSerializer::toQueryValue($allowOverwrite, null);
        }
        // header params
        if ($evApiKey !== null) {
            $headerParams['ev-api-key'] = ObjectSerializer::toHeaderValue($evApiKey);
        }
        // header params
        if ($evAccessToken !== null) {
            $headerParams['ev-access-token'] = ObjectSerializer::toHeaderValue($evAccessToken);
        }
        // header params
        if ($offsetBytes !== null) {
            $headerParams['offsetBytes'] = ObjectSerializer::toHeaderValue($offsetBytes);
        }


        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
