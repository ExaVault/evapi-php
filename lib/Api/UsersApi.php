<?php
/**
 * UsersApi
 * PHP version 5
 *
 * @category Class
 * @package  ExaVault
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * ExaVault API
 *
 * See our API reference documentation at https://www.exavault.com/developer/api-docs/
 *
 * OpenAPI spec version: 2.0
 * Contact: support@exavault.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.22
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace ExaVault\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use ExaVault\ApiException;
use ExaVault\Configuration;
use ExaVault\HeaderSelector;
use ExaVault\ObjectSerializer;

/**
 * UsersApi Class Doc Comment
 *
 * @category Class
 * @package  ExaVault
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class UsersApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addUser
     *
     * Create a user
     *
     * @param  string $evApiKey API key required to make the API call (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  \ExaVault\Model\AddUserRequestBody $body body (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ExaVault\Model\UserResponse
     */
    public function addUser($evApiKey, $evAccessToken, $body = null)
    {
        list($response) = $this->addUserWithHttpInfo($evApiKey, $evAccessToken, $body);
        return $response;
    }

    /**
     * Operation addUserWithHttpInfo
     *
     * Create a user
     *
     * @param  string $evApiKey API key required to make the API call (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  \ExaVault\Model\AddUserRequestBody $body (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ExaVault\Model\UserResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function addUserWithHttpInfo($evApiKey, $evAccessToken, $body = null)
    {
        $returnType = '\ExaVault\Model\UserResponse';
        $request = $this->addUserRequest($evApiKey, $evAccessToken, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ExaVault\Model\UserResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addUserAsync
     *
     * Create a user
     *
     * @param  string $evApiKey API key required to make the API call (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  \ExaVault\Model\AddUserRequestBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addUserAsync($evApiKey, $evAccessToken, $body = null)
    {
        return $this->addUserAsyncWithHttpInfo($evApiKey, $evAccessToken, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addUserAsyncWithHttpInfo
     *
     * Create a user
     *
     * @param  string $evApiKey API key required to make the API call (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  \ExaVault\Model\AddUserRequestBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addUserAsyncWithHttpInfo($evApiKey, $evAccessToken, $body = null)
    {
        $returnType = '\ExaVault\Model\UserResponse';
        $request = $this->addUserRequest($evApiKey, $evAccessToken, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addUser'
     *
     * @param  string $evApiKey API key required to make the API call (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  \ExaVault\Model\AddUserRequestBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addUserRequest($evApiKey, $evAccessToken, $body = null)
    {
        // verify the required parameter 'evApiKey' is set
        if ($evApiKey === null || (is_array($evApiKey) && count($evApiKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evApiKey when calling addUser'
            );
        }
        // verify the required parameter 'evAccessToken' is set
        if ($evAccessToken === null || (is_array($evAccessToken) && count($evAccessToken) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evAccessToken when calling addUser'
            );
        }

        $resourcePath = '/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($evApiKey !== null) {
            $headerParams['ev-api-key'] = ObjectSerializer::toHeaderValue($evApiKey);
        }
        // header params
        if ($evAccessToken !== null) {
            $headerParams['ev-access-token'] = ObjectSerializer::toHeaderValue($evAccessToken);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteUser
     *
     * Delete a user
     *
     * @param  float $id The user&#x27;s ID. Note that this is our internal ID, and _not the username_. You can obtain it by calling the [GET /users](#operation/listUsers) method. (required)
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ExaVault\Model\EmptyResponse
     */
    public function deleteUser($id, $evApiKey, $evAccessToken)
    {
        list($response) = $this->deleteUserWithHttpInfo($id, $evApiKey, $evAccessToken);
        return $response;
    }

    /**
     * Operation deleteUserWithHttpInfo
     *
     * Delete a user
     *
     * @param  float $id The user&#x27;s ID. Note that this is our internal ID, and _not the username_. You can obtain it by calling the [GET /users](#operation/listUsers) method. (required)
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ExaVault\Model\EmptyResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteUserWithHttpInfo($id, $evApiKey, $evAccessToken)
    {
        $returnType = '\ExaVault\Model\EmptyResponse';
        $request = $this->deleteUserRequest($id, $evApiKey, $evAccessToken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ExaVault\Model\EmptyResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteUserAsync
     *
     * Delete a user
     *
     * @param  float $id The user&#x27;s ID. Note that this is our internal ID, and _not the username_. You can obtain it by calling the [GET /users](#operation/listUsers) method. (required)
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteUserAsync($id, $evApiKey, $evAccessToken)
    {
        return $this->deleteUserAsyncWithHttpInfo($id, $evApiKey, $evAccessToken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteUserAsyncWithHttpInfo
     *
     * Delete a user
     *
     * @param  float $id The user&#x27;s ID. Note that this is our internal ID, and _not the username_. You can obtain it by calling the [GET /users](#operation/listUsers) method. (required)
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteUserAsyncWithHttpInfo($id, $evApiKey, $evAccessToken)
    {
        $returnType = '\ExaVault\Model\EmptyResponse';
        $request = $this->deleteUserRequest($id, $evApiKey, $evAccessToken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteUser'
     *
     * @param  float $id The user&#x27;s ID. Note that this is our internal ID, and _not the username_. You can obtain it by calling the [GET /users](#operation/listUsers) method. (required)
     * @param  string $evApiKey API Key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteUserRequest($id, $evApiKey, $evAccessToken)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteUser'
            );
        }
        // verify the required parameter 'evApiKey' is set
        if ($evApiKey === null || (is_array($evApiKey) && count($evApiKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evApiKey when calling deleteUser'
            );
        }
        // verify the required parameter 'evAccessToken' is set
        if ($evAccessToken === null || (is_array($evAccessToken) && count($evAccessToken) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evAccessToken when calling deleteUser'
            );
        }

        $resourcePath = '/users/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($evApiKey !== null) {
            $headerParams['ev-api-key'] = ObjectSerializer::toHeaderValue($evApiKey);
        }
        // header params
        if ($evAccessToken !== null) {
            $headerParams['ev-access-token'] = ObjectSerializer::toHeaderValue($evAccessToken);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUserById
     *
     * Get info for a user
     *
     * @param  float $id The user&#x27;s ID. Note that this is our internal ID, and _not the username_. You can obtain it by calling the [GET /users](#operation/listUsers) method. (required)
     * @param  string $evApiKey API Key (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $include Comma-separated list of relationships to include in response. Possible values include **homeResource** and **ownerAccount**. (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ExaVault\Model\UserResponse
     */
    public function getUserById($id, $evApiKey, $evAccessToken, $include = null)
    {
        list($response) = $this->getUserByIdWithHttpInfo($id, $evApiKey, $evAccessToken, $include);
        return $response;
    }

    /**
     * Operation getUserByIdWithHttpInfo
     *
     * Get info for a user
     *
     * @param  float $id The user&#x27;s ID. Note that this is our internal ID, and _not the username_. You can obtain it by calling the [GET /users](#operation/listUsers) method. (required)
     * @param  string $evApiKey API Key (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $include Comma-separated list of relationships to include in response. Possible values include **homeResource** and **ownerAccount**. (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ExaVault\Model\UserResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUserByIdWithHttpInfo($id, $evApiKey, $evAccessToken, $include = null)
    {
        $returnType = '\ExaVault\Model\UserResponse';
        $request = $this->getUserByIdRequest($id, $evApiKey, $evAccessToken, $include);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ExaVault\Model\UserResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getUserByIdAsync
     *
     * Get info for a user
     *
     * @param  float $id The user&#x27;s ID. Note that this is our internal ID, and _not the username_. You can obtain it by calling the [GET /users](#operation/listUsers) method. (required)
     * @param  string $evApiKey API Key (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $include Comma-separated list of relationships to include in response. Possible values include **homeResource** and **ownerAccount**. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserByIdAsync($id, $evApiKey, $evAccessToken, $include = null)
    {
        return $this->getUserByIdAsyncWithHttpInfo($id, $evApiKey, $evAccessToken, $include)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUserByIdAsyncWithHttpInfo
     *
     * Get info for a user
     *
     * @param  float $id The user&#x27;s ID. Note that this is our internal ID, and _not the username_. You can obtain it by calling the [GET /users](#operation/listUsers) method. (required)
     * @param  string $evApiKey API Key (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $include Comma-separated list of relationships to include in response. Possible values include **homeResource** and **ownerAccount**. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserByIdAsyncWithHttpInfo($id, $evApiKey, $evAccessToken, $include = null)
    {
        $returnType = '\ExaVault\Model\UserResponse';
        $request = $this->getUserByIdRequest($id, $evApiKey, $evAccessToken, $include);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUserById'
     *
     * @param  float $id The user&#x27;s ID. Note that this is our internal ID, and _not the username_. You can obtain it by calling the [GET /users](#operation/listUsers) method. (required)
     * @param  string $evApiKey API Key (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $include Comma-separated list of relationships to include in response. Possible values include **homeResource** and **ownerAccount**. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getUserByIdRequest($id, $evApiKey, $evAccessToken, $include = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getUserById'
            );
        }
        // verify the required parameter 'evApiKey' is set
        if ($evApiKey === null || (is_array($evApiKey) && count($evApiKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evApiKey when calling getUserById'
            );
        }
        // verify the required parameter 'evAccessToken' is set
        if ($evAccessToken === null || (is_array($evAccessToken) && count($evAccessToken) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evAccessToken when calling getUserById'
            );
        }

        $resourcePath = '/users/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include !== null) {
            $queryParams['include'] = ObjectSerializer::toQueryValue($include, null);
        }
        // header params
        if ($evApiKey !== null) {
            $headerParams['ev-api-key'] = ObjectSerializer::toHeaderValue($evApiKey);
        }
        // header params
        if ($evAccessToken !== null) {
            $headerParams['ev-access-token'] = ObjectSerializer::toHeaderValue($evAccessToken);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listUsers
     *
     * Get a list of users
     *
     * @param  string $evApiKey API key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $username The username of the user you are looking for. Only entries with the same username as this will be in the list of results. Does not support wildcard searches. (optional)
     * @param  string $nickname Nickname to search for. Ignored if &#x60;username&#x60; is provided. Supports wildcard searches. (optional)
     * @param  string $email Email to search for. Ignored if &#x60;username&#x60; is provided. Supports wildcard searches (optional)
     * @param  string $role Types of users to include the list. Ignored if &#x60;username&#x60; is provided. Valid options are **admin**, **master** and **user** (optional)
     * @param  int $status Whether a user is locked. Ignored if &#x60;username&#x60; is provided. **0** means user is locked, **1** means user is not locked. (optional)
     * @param  string $homeDir Path for user&#x27;s home directory. Ignored if &#x60;username&#x60; is provided. Supports wildcard searches. (optional)
     * @param  string $search Searches the nickname, email, role and homeDir fields for the provided value. Ignored if &#x60;username&#x60; is provided. Supports wildcard searches. (optional)
     * @param  int $offset Starting user record in the result set. Can be used for pagination. (optional)
     * @param  string $sort Sort order or matching users. You can sort by multiple columns by separating sort options with a comma; the sort will be applied in the order specified. The sort order for each sort field is ascending unless it is prefixed with a minus (“-“), in which case it will be descending.  Valid sort fields are: **nickname**, **username**, **email**, **homeDir** and **modified** (optional)
     * @param  int $limit Number of users to return. Can be used for pagination. (optional)
     * @param  string $include Comma separated list of relationships to include in response. Valid options are **homeResource** and **ownerAccount**. (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ExaVault\Model\UserCollectionResponse
     */
    public function listUsers($evApiKey, $evAccessToken, $username = null, $nickname = null, $email = null, $role = null, $status = null, $homeDir = null, $search = null, $offset = null, $sort = null, $limit = null, $include = null)
    {
        list($response) = $this->listUsersWithHttpInfo($evApiKey, $evAccessToken, $username, $nickname, $email, $role, $status, $homeDir, $search, $offset, $sort, $limit, $include);
        return $response;
    }

    /**
     * Operation listUsersWithHttpInfo
     *
     * Get a list of users
     *
     * @param  string $evApiKey API key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $username The username of the user you are looking for. Only entries with the same username as this will be in the list of results. Does not support wildcard searches. (optional)
     * @param  string $nickname Nickname to search for. Ignored if &#x60;username&#x60; is provided. Supports wildcard searches. (optional)
     * @param  string $email Email to search for. Ignored if &#x60;username&#x60; is provided. Supports wildcard searches (optional)
     * @param  string $role Types of users to include the list. Ignored if &#x60;username&#x60; is provided. Valid options are **admin**, **master** and **user** (optional)
     * @param  int $status Whether a user is locked. Ignored if &#x60;username&#x60; is provided. **0** means user is locked, **1** means user is not locked. (optional)
     * @param  string $homeDir Path for user&#x27;s home directory. Ignored if &#x60;username&#x60; is provided. Supports wildcard searches. (optional)
     * @param  string $search Searches the nickname, email, role and homeDir fields for the provided value. Ignored if &#x60;username&#x60; is provided. Supports wildcard searches. (optional)
     * @param  int $offset Starting user record in the result set. Can be used for pagination. (optional)
     * @param  string $sort Sort order or matching users. You can sort by multiple columns by separating sort options with a comma; the sort will be applied in the order specified. The sort order for each sort field is ascending unless it is prefixed with a minus (“-“), in which case it will be descending.  Valid sort fields are: **nickname**, **username**, **email**, **homeDir** and **modified** (optional)
     * @param  int $limit Number of users to return. Can be used for pagination. (optional)
     * @param  string $include Comma separated list of relationships to include in response. Valid options are **homeResource** and **ownerAccount**. (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ExaVault\Model\UserCollectionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listUsersWithHttpInfo($evApiKey, $evAccessToken, $username = null, $nickname = null, $email = null, $role = null, $status = null, $homeDir = null, $search = null, $offset = null, $sort = null, $limit = null, $include = null)
    {
        $returnType = '\ExaVault\Model\UserCollectionResponse';
        $request = $this->listUsersRequest($evApiKey, $evAccessToken, $username, $nickname, $email, $role, $status, $homeDir, $search, $offset, $sort, $limit, $include);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ExaVault\Model\UserCollectionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listUsersAsync
     *
     * Get a list of users
     *
     * @param  string $evApiKey API key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $username The username of the user you are looking for. Only entries with the same username as this will be in the list of results. Does not support wildcard searches. (optional)
     * @param  string $nickname Nickname to search for. Ignored if &#x60;username&#x60; is provided. Supports wildcard searches. (optional)
     * @param  string $email Email to search for. Ignored if &#x60;username&#x60; is provided. Supports wildcard searches (optional)
     * @param  string $role Types of users to include the list. Ignored if &#x60;username&#x60; is provided. Valid options are **admin**, **master** and **user** (optional)
     * @param  int $status Whether a user is locked. Ignored if &#x60;username&#x60; is provided. **0** means user is locked, **1** means user is not locked. (optional)
     * @param  string $homeDir Path for user&#x27;s home directory. Ignored if &#x60;username&#x60; is provided. Supports wildcard searches. (optional)
     * @param  string $search Searches the nickname, email, role and homeDir fields for the provided value. Ignored if &#x60;username&#x60; is provided. Supports wildcard searches. (optional)
     * @param  int $offset Starting user record in the result set. Can be used for pagination. (optional)
     * @param  string $sort Sort order or matching users. You can sort by multiple columns by separating sort options with a comma; the sort will be applied in the order specified. The sort order for each sort field is ascending unless it is prefixed with a minus (“-“), in which case it will be descending.  Valid sort fields are: **nickname**, **username**, **email**, **homeDir** and **modified** (optional)
     * @param  int $limit Number of users to return. Can be used for pagination. (optional)
     * @param  string $include Comma separated list of relationships to include in response. Valid options are **homeResource** and **ownerAccount**. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listUsersAsync($evApiKey, $evAccessToken, $username = null, $nickname = null, $email = null, $role = null, $status = null, $homeDir = null, $search = null, $offset = null, $sort = null, $limit = null, $include = null)
    {
        return $this->listUsersAsyncWithHttpInfo($evApiKey, $evAccessToken, $username, $nickname, $email, $role, $status, $homeDir, $search, $offset, $sort, $limit, $include)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listUsersAsyncWithHttpInfo
     *
     * Get a list of users
     *
     * @param  string $evApiKey API key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $username The username of the user you are looking for. Only entries with the same username as this will be in the list of results. Does not support wildcard searches. (optional)
     * @param  string $nickname Nickname to search for. Ignored if &#x60;username&#x60; is provided. Supports wildcard searches. (optional)
     * @param  string $email Email to search for. Ignored if &#x60;username&#x60; is provided. Supports wildcard searches (optional)
     * @param  string $role Types of users to include the list. Ignored if &#x60;username&#x60; is provided. Valid options are **admin**, **master** and **user** (optional)
     * @param  int $status Whether a user is locked. Ignored if &#x60;username&#x60; is provided. **0** means user is locked, **1** means user is not locked. (optional)
     * @param  string $homeDir Path for user&#x27;s home directory. Ignored if &#x60;username&#x60; is provided. Supports wildcard searches. (optional)
     * @param  string $search Searches the nickname, email, role and homeDir fields for the provided value. Ignored if &#x60;username&#x60; is provided. Supports wildcard searches. (optional)
     * @param  int $offset Starting user record in the result set. Can be used for pagination. (optional)
     * @param  string $sort Sort order or matching users. You can sort by multiple columns by separating sort options with a comma; the sort will be applied in the order specified. The sort order for each sort field is ascending unless it is prefixed with a minus (“-“), in which case it will be descending.  Valid sort fields are: **nickname**, **username**, **email**, **homeDir** and **modified** (optional)
     * @param  int $limit Number of users to return. Can be used for pagination. (optional)
     * @param  string $include Comma separated list of relationships to include in response. Valid options are **homeResource** and **ownerAccount**. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listUsersAsyncWithHttpInfo($evApiKey, $evAccessToken, $username = null, $nickname = null, $email = null, $role = null, $status = null, $homeDir = null, $search = null, $offset = null, $sort = null, $limit = null, $include = null)
    {
        $returnType = '\ExaVault\Model\UserCollectionResponse';
        $request = $this->listUsersRequest($evApiKey, $evAccessToken, $username, $nickname, $email, $role, $status, $homeDir, $search, $offset, $sort, $limit, $include);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listUsers'
     *
     * @param  string $evApiKey API key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  string $username The username of the user you are looking for. Only entries with the same username as this will be in the list of results. Does not support wildcard searches. (optional)
     * @param  string $nickname Nickname to search for. Ignored if &#x60;username&#x60; is provided. Supports wildcard searches. (optional)
     * @param  string $email Email to search for. Ignored if &#x60;username&#x60; is provided. Supports wildcard searches (optional)
     * @param  string $role Types of users to include the list. Ignored if &#x60;username&#x60; is provided. Valid options are **admin**, **master** and **user** (optional)
     * @param  int $status Whether a user is locked. Ignored if &#x60;username&#x60; is provided. **0** means user is locked, **1** means user is not locked. (optional)
     * @param  string $homeDir Path for user&#x27;s home directory. Ignored if &#x60;username&#x60; is provided. Supports wildcard searches. (optional)
     * @param  string $search Searches the nickname, email, role and homeDir fields for the provided value. Ignored if &#x60;username&#x60; is provided. Supports wildcard searches. (optional)
     * @param  int $offset Starting user record in the result set. Can be used for pagination. (optional)
     * @param  string $sort Sort order or matching users. You can sort by multiple columns by separating sort options with a comma; the sort will be applied in the order specified. The sort order for each sort field is ascending unless it is prefixed with a minus (“-“), in which case it will be descending.  Valid sort fields are: **nickname**, **username**, **email**, **homeDir** and **modified** (optional)
     * @param  int $limit Number of users to return. Can be used for pagination. (optional)
     * @param  string $include Comma separated list of relationships to include in response. Valid options are **homeResource** and **ownerAccount**. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listUsersRequest($evApiKey, $evAccessToken, $username = null, $nickname = null, $email = null, $role = null, $status = null, $homeDir = null, $search = null, $offset = null, $sort = null, $limit = null, $include = null)
    {
        // verify the required parameter 'evApiKey' is set
        if ($evApiKey === null || (is_array($evApiKey) && count($evApiKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evApiKey when calling listUsers'
            );
        }
        // verify the required parameter 'evAccessToken' is set
        if ($evAccessToken === null || (is_array($evAccessToken) && count($evAccessToken) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evAccessToken when calling listUsers'
            );
        }

        $resourcePath = '/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($username !== null) {
            $queryParams['username'] = ObjectSerializer::toQueryValue($username, null);
        }
        // query params
        if ($nickname !== null) {
            $queryParams['nickname'] = ObjectSerializer::toQueryValue($nickname, null);
        }
        // query params
        if ($email !== null) {
            $queryParams['email'] = ObjectSerializer::toQueryValue($email, null);
        }
        // query params
        if ($role !== null) {
            $queryParams['role'] = ObjectSerializer::toQueryValue($role, null);
        }
        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status, null);
        }
        // query params
        if ($homeDir !== null) {
            $queryParams['homeDir'] = ObjectSerializer::toQueryValue($homeDir, null);
        }
        // query params
        if ($search !== null) {
            $queryParams['search'] = ObjectSerializer::toQueryValue($search, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, 'int32');
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort, null);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, 'int32');
        }
        // query params
        if ($include !== null) {
            $queryParams['include'] = ObjectSerializer::toQueryValue($include, null);
        }
        // header params
        if ($evApiKey !== null) {
            $headerParams['ev-api-key'] = ObjectSerializer::toHeaderValue($evApiKey);
        }
        // header params
        if ($evAccessToken !== null) {
            $headerParams['ev-access-token'] = ObjectSerializer::toHeaderValue($evAccessToken);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateUser
     *
     * Update a user
     *
     * @param  string $evApiKey API key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  float $id The user&#x27;s ID. Note that this is our internal ID, and _not the username_. You can obtain it by calling the [GET /users](#operation/listUsers) method. (required)
     * @param  \ExaVault\Model\UpdateUserRequestBody $body body (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ExaVault\Model\UserResponse
     */
    public function updateUser($evApiKey, $evAccessToken, $id, $body = null)
    {
        list($response) = $this->updateUserWithHttpInfo($evApiKey, $evAccessToken, $id, $body);
        return $response;
    }

    /**
     * Operation updateUserWithHttpInfo
     *
     * Update a user
     *
     * @param  string $evApiKey API key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  float $id The user&#x27;s ID. Note that this is our internal ID, and _not the username_. You can obtain it by calling the [GET /users](#operation/listUsers) method. (required)
     * @param  \ExaVault\Model\UpdateUserRequestBody $body (optional)
     *
     * @throws \ExaVault\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ExaVault\Model\UserResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateUserWithHttpInfo($evApiKey, $evAccessToken, $id, $body = null)
    {
        $returnType = '\ExaVault\Model\UserResponse';
        $request = $this->updateUserRequest($evApiKey, $evAccessToken, $id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ExaVault\Model\UserResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateUserAsync
     *
     * Update a user
     *
     * @param  string $evApiKey API key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  float $id The user&#x27;s ID. Note that this is our internal ID, and _not the username_. You can obtain it by calling the [GET /users](#operation/listUsers) method. (required)
     * @param  \ExaVault\Model\UpdateUserRequestBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateUserAsync($evApiKey, $evAccessToken, $id, $body = null)
    {
        return $this->updateUserAsyncWithHttpInfo($evApiKey, $evAccessToken, $id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateUserAsyncWithHttpInfo
     *
     * Update a user
     *
     * @param  string $evApiKey API key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  float $id The user&#x27;s ID. Note that this is our internal ID, and _not the username_. You can obtain it by calling the [GET /users](#operation/listUsers) method. (required)
     * @param  \ExaVault\Model\UpdateUserRequestBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateUserAsyncWithHttpInfo($evApiKey, $evAccessToken, $id, $body = null)
    {
        $returnType = '\ExaVault\Model\UserResponse';
        $request = $this->updateUserRequest($evApiKey, $evAccessToken, $id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateUser'
     *
     * @param  string $evApiKey API key required to make the API call. (required)
     * @param  string $evAccessToken Access token required to make the API call. (required)
     * @param  float $id The user&#x27;s ID. Note that this is our internal ID, and _not the username_. You can obtain it by calling the [GET /users](#operation/listUsers) method. (required)
     * @param  \ExaVault\Model\UpdateUserRequestBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateUserRequest($evApiKey, $evAccessToken, $id, $body = null)
    {
        // verify the required parameter 'evApiKey' is set
        if ($evApiKey === null || (is_array($evApiKey) && count($evApiKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evApiKey when calling updateUser'
            );
        }
        // verify the required parameter 'evAccessToken' is set
        if ($evAccessToken === null || (is_array($evAccessToken) && count($evAccessToken) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $evAccessToken when calling updateUser'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateUser'
            );
        }

        $resourcePath = '/users/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($evApiKey !== null) {
            $headerParams['ev-api-key'] = ObjectSerializer::toHeaderValue($evApiKey);
        }
        // header params
        if ($evAccessToken !== null) {
            $headerParams['ev-access-token'] = ObjectSerializer::toHeaderValue($evAccessToken);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
